<!DOCTYPE html>
<html lang="zh-CN">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 7.2.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://example.com/2024/10/28/八股/redis/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
    <link rel="shortcut icon" type='image/x-icon' href="https://pic1.imgdb.cn/item/678f67f7d0e0a243d4f624cc.png">
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>Redis - light</title>
  <meta name="keywords" content="Redis,null">
  <meta desc name="description" content="这里是Redis相关的八股 - Light - light">
  
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/Redis/index.html">
<meta property="og:site_name" content="light">
<meta property="og:description" content="这里是Redis相关的八股">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2024-10-28T12:14:56.000Z">
<meta property="article:modified_time" content="2025-09-07T07:47:32.637Z">
<meta property="article:author" content="Light">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #e8f5e9;
  --color-site-bg: #e8f5e9;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #3dd9b6;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.featured .menu .list-h {
  margin: -2px;
}
.cover-wrapper.featured .menu .list-h a {
  margin: 2px;
  background: rgba(255,255,255,0.5);
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.featured .menu .list-h a {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }
  :root:not([color-scheme]) {
    --color-site-body: #121212;
    --color-read-bkg: #1f1f1f;
    --color-read-post: #262626;
    --color-site-bg: #1f1f1f;
    --color-site-inner: rgba(238,238,238,0.871);
    --color-site-footer: rgba(170,170,170,0.871);
    --color-card: #262626;
    --color-text: rgba(238,238,238,0.871);
    --color-block: #434343;
    --color-codeblock: #1f1f1f;
    --color-inlinecode: #d56d28;
    --color-h1: rgba(255,255,255,0.871);
    --color-h2: rgba(255,255,255,0.871);
    --color-h3: rgba(255,255,255,0.6);
    --color-h4: rgba(255,255,255,0.6);
    --color-h5: rgba(255,255,255,0.6);
    --color-h6: rgba(255,255,255,0.6);
    --color-p: rgba(217,217,217,0.871);
    --color-list: rgba(217,217,217,0.871);
    --color-list-hl: #63e0c4;
    --color-meta: rgba(191,191,191,0.871);
    --color-link: rgba(191,191,191,0.871);
    --color-copyright-bkg: #21252b;
  }
  :root:not([color-scheme]) img {
    filter: brightness(70%) !important;
  }
  :root:not([color-scheme]) .blur {
    background: rgba(31,31,31,0.9) !important;
  }
  :root:not([color-scheme]) .white-box.blur {
    background: rgba(38,38,38,0.9) !important;
  }
  :root:not([color-scheme]) .nav-main .u-search-input {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a:hover {
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) .article blockquote {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .article-title a {
    color: var(--color-h1) !important;
  }
  :root:not([color-scheme]) details>summary {
    color: var(--color-p) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) details {
    border: 1px solid var(--color-site-bg) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) #u-search .modal,
  :root:not([color-scheme]) #u-search .modal-header,
  :root:not([color-scheme]) #u-search .modal-body {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #u-search .modal-body .modal-results .result:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:focus {
    background: var(--color-site-body) !important;
  }
}
[color-scheme='dark'] {
  --color-site-body: #121212;
  --color-read-bkg: #1f1f1f;
  --color-read-post: #262626;
  --color-site-bg: #1f1f1f;
  --color-site-inner: rgba(238,238,238,0.871);
  --color-site-footer: rgba(170,170,170,0.871);
  --color-card: #262626;
  --color-text: rgba(238,238,238,0.871);
  --color-block: #434343;
  --color-codeblock: #1f1f1f;
  --color-inlinecode: #d56d28;
  --color-h1: rgba(255,255,255,0.871);
  --color-h2: rgba(255,255,255,0.871);
  --color-h3: rgba(255,255,255,0.6);
  --color-h4: rgba(255,255,255,0.6);
  --color-h5: rgba(255,255,255,0.6);
  --color-h6: rgba(255,255,255,0.6);
  --color-p: rgba(217,217,217,0.871);
  --color-list: rgba(217,217,217,0.871);
  --color-list-hl: #63e0c4;
  --color-meta: rgba(191,191,191,0.871);
  --color-link: rgba(191,191,191,0.871);
  --color-copyright-bkg: #21252b;
}
[color-scheme='dark'] img {
  filter: brightness(70%) !important;
}
[color-scheme='dark'] .blur {
  background: rgba(31,31,31,0.9) !important;
}
[color-scheme='dark'] .white-box.blur {
  background: rgba(38,38,38,0.9) !important;
}
[color-scheme='dark'] .nav-main .u-search-input {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a {
  background: var(--color-block) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a:hover {
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] .article blockquote {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .article-title a {
  color: var(--color-h1) !important;
}
[color-scheme='dark'] details>summary {
  color: var(--color-p) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] details {
  border: 1px solid var(--color-site-bg) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] #u-search .modal,
[color-scheme='dark'] #u-search .modal-header,
[color-scheme='dark'] #u-search .modal-body {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #u-search .modal-body .modal-results .result:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:focus {
  background: var(--color-site-body) !important;
}
@media screen and (max-width: 500px) {
  [color-scheme='dark'] .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper .m_search {
  margin-left: auto;
  margin-right: 16px;
}
#wrapper .menu {
  order: 1;
}
#wrapper .menu li ul.list-v {
  right: 0;
}
#wrapper .menu li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}
@media screen and (prefers-color-scheme: dark) and (max-width: 500px) {
  .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
    <script>
      let userColorScheme=localStorage.getItem("color-scheme")
      if(userColorScheme){
        document.documentElement.setAttribute("color-scheme", userColorScheme);
      }
    </script>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "false"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: false,
    cdn: {"js":{"app":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/app.js","parallax":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/parallax.js","rightMenu":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/rightMenu.js","rightMenus":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/rightMenus.js","sites":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/tags/sites.js","friends":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/tags/friends.js","contributors":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/tags/contributors.js","search":"https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1761641439108),
    sidebar: {
      for_page: ["blogger","category","donate","webinfo"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2024/09/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      
      rightmenu: {
        faicon: "fa",
        layout: ["home","hr","help","examples","contributors","hr","source_docs","source_theme","hr","print","darkmode","reading","music"],
        music_alwaysShow: true,
        customPicUrl: {"enable":false,"old":null,"new":null}
      },
      
      
      rightmenus: {"enable":true,"order":["plugins.navigation","hr","plugins.inputBox","plugins.seletctText","plugins.elementCheck","plugins.elementImage","menus.link","hr","menus.darkMode","plugins.articlePage","music"],"options":{"iconPrefix":"fa-solid","articleShowLink":true,"musicAlwaysShow":true},"plugins":{"navigation":[{"id":"left","name":"转到上一页","icon":"fa-solid fa-arrow-left","event":"history.back()","group":"navigation"},{"id":"right","name":"转到下一页","icon":"fa-solid fa-arrow-right","event":"history.forward()","group":"navigation"},{"id":"redo","name":"刷新当前页面","icon":"fa-solid fa-redo","event":"window.location.reload()","group":"navigation"},{"id":"up","name":"回到顶部","icon":"fa-solid fa-arrow-up","event":"VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)","group":"navigation"}],"inputBox":[{"id":"copyPaste","name":"粘贴文本","icon":"fa-solid fa-paste","event":"copyPaste","group":"inputBox"},{"id":"copyAll","name":"全选文本","icon":"fa-solid fa-object-ungroup","event":"copyAll","group":"inputBox"},{"id":"copyCut","name":"剪切文本","icon":"fa-solid fa-cut","event":"copyCut","group":"inputBox"}],"seletctText":[{"id":"copyText","name":"复制文本","icon":"fa-solid fa-copy","event":"copyText","group":"seletctText"},{"id":"searchWord","name":"站内搜索","icon":"fa-solid fa-search","event":"OpenSearch(__text__)","group":"seletctText"},{"id":"bingSearch","name":"必应搜索","icon":"fa-solid fa-search","event":"window.open(`https://cn.bing.com/search?q=${__text__}`)","group":"seletctText"}],"elementCheck":[{"id":"openTab","name":"新标签页打开","icon":"fa-solid fa-external-link-square-alt","event":"window.open(__link__)","group":"elementCheck"},{"id":"copyLink","name":"复制链接地址","icon":"fa-solid fa-link","event":"copyLink","group":"elementCheck"}],"elementImage":[{"id":"copyImg","name":"复制图片","icon":"fa-solid fa-image","event":"copyImg","group":"elementImage"},{"id":"googleImg","name":"谷歌识图","icon":"fa-solid fa-images","event":"window.open(`https://www.google.com.hk/searchbyimage?image_url=${__link__}`)","group":"elementImage"}],"articlePage":[{"id":"printMode","name":"打印页面","icon":"fa-solid fa-print","event":"printMode","group":"articlePage"},{"id":"readMode","name":"阅读模式","icon":"fa-solid fa-book-open","event":"readMode","group":"articlePage"}]},"menus":{"link":[{"id":"help","name":"常见问题","icon":"fa-solid fa-question","link":"https://volantis.js.org/faqs/","group":"link"},{"id":"examples","name":"示例博客","icon":"fa-solid fa-rss","link":"https://volantis.js.org/examples/","group":"link"},{"id":"contributors","name":"加入社区","icon":"fa-solid fa-fan","link":"https://volantis.js.org/contributors/","group":"link"},"hr",{"id":"source_docs","name":"本站源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/volantis-docs/","group":"link"},{"id":"source_theme","name":"主题源码","icon":"fa-solid fa-code-branch","link":"https://github.com/volantis-x/hexo-theme-volantis/","group":"link"}],"darkMode":[{"id":"darkMode","name":"暗黑模式","icon":"fa-solid fa-moon","event":"volantis.dark.toggle()","group":"darkMode"}]}}
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            Home
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="学习"
                  
                  
                  >
                  <i class='fas fa-chalkboard-teacher fa-fw'></i>学习
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/Java8/" title="Java八股"
                  
                  
                  
                    active-action="action-Java8"
                  >
                  <i class='fas fa-coffee fa-fw'></i>Java八股
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/2024/12/13/hot100%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%9D%E8%B7%AF/" title="刷题"
                  
                  
                  
                    active-action="action-20241213hot100E4B880E58FA5E8AF9DE6809DE8B7AF"
                  >
                  <i class='fas fa-bug fa-fw'></i>刷题
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="生活"
                  
                  
                  >
                  <i class='fas fa-seedling fa-fw'></i>生活
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li class='header'>
                <i class='fas fa-music fa-fw'></i>音乐
              </li>
            
          
                    
                      
            
              <li class='header'>
                <i class='fas fa-camera-retro fa-fw'></i>图片
              </li>
            
          
                    
                      
            
              <li class='header'>
                <i class='fas fa-pencil fa-fw'></i>随笔
              </li>
            
          
                    
                      
            
              <li class='header'>
                <i class='fas fa-grin-stars fa-fw'></i>动漫
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/2024/10/10/%E5%BD%B1%E8%A7%86%E7%82%B9%E8%AF%84/" title="影视"
                  
                  
                  
                    active-action="action-20241010E5BDB1E8A786E782B9E8AF84"
                  >
                  <i class='fas fa-grin-stars fa-fw'></i>影视
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="搜点什么好呢？" />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="学习"
                  
                  
                  >
                  <i class='fas fa-chalkboard-teacher fa-fw'></i>学习
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/Java8/" title="Java八股"
                  
                  
                  
                    active-action="action-Java8"
                  >
                  <i class='fas fa-coffee fa-fw'></i>Java八股
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/2024/12/13/hot100%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%9D%E8%B7%AF/" title="刷题"
                  
                  
                  
                    active-action="action-20241213hot100E4B880E58FA5E8AF9DE6809DE8B7AF"
                  >
                  <i class='fas fa-bug fa-fw'></i>刷题
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="生活"
                  
                  
                  >
                  <i class='fas fa-seedling fa-fw'></i>生活
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li class='header'>
                <i class='fas fa-music fa-fw'></i>音乐
              </li>
            
          
                    
                      
            
              <li class='header'>
                <i class='fas fa-camera-retro fa-fw'></i>图片
              </li>
            
          
                    
                      
            
              <li class='header'>
                <i class='fas fa-pencil fa-fw'></i>随笔
              </li>
            
          
                    
                      
            
              <li class='header'>
                <i class='fas fa-grin-stars fa-fw'></i>动漫
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/2024/10/10/%E5%BD%B1%E8%A7%86%E7%82%B9%E8%AF%84/" title="影视"
                  
                  
                  
                    active-action="action-20241010E5BDB1E8A786E782B9E8AF84"
                  >
                  <i class='fas fa-grin-stars fa-fw'></i>影视
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-solid fa-moon fa-fw'></i>暗黑模式
                </a>
              <li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="none" class='cover-wrapper post featured' style="display: none;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://pic1.imgdb.cn/item/678f95a6d0e0a243d4f62c50.jpg"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Light</p>
    
    
      <p class="subtitle">⌈我与我周旋 宁作我⌋</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/28/八股/Redis/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="light">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="light">
    <meta itemprop="description" content="啊咧咧啊咧咧啊咧啊咧咧~">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        Redis
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' href="/" rel="nofollow">
    <img itemprop="image" src="https://pic1.imgdb.cn/item/678f654fd0e0a243d4f62447.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/678f654fd0e0a243d4f62447.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">Light</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url"><span itemprop="name">八股</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2024-10-28T20:14:56+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2024年10月28日</p>
  </a>
</div>

          
        
          
            


<div class="new-meta-item browse">
  <a class='notlink'>
    <p>
      <i class="fa-solid fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="busuanzi_value_page_pv"><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span>
      
      <span>次浏览</span>
    </p>
  </a>
</div>


          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fa-solid fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：25.1k 字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fa-solid fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：88 分钟</p>
    </a>
  </div>


          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <p>这里是Redis相关的八股</p>
<span id="more"></span>



<p>Redis默认端口6379</p>
<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h2 id="1-Redis为什么快？"><a href="#1-Redis为什么快？" class="headerlink" title="1.Redis为什么快？"></a>1.Redis为什么快？</h2><ul>
<li><p><strong>内存操作：</strong>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速</p>
</li>
<li><p><strong>I&#x2F;O多路复用模型：</strong>采用了 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求，其中的 IO 多路复用技术可以在只有一个线程的情况下，同时监听成千上万个客户端连接，解决传统 IO 模型中每个连接都需要一个独立线程带来的性能开销。</p>
</li>
</ul>
<h2 id="2-Redis有哪些数据类型？常用的使用场景"><a href="#2-Redis有哪些数据类型？常用的使用场景" class="headerlink" title="2.Redis有哪些数据类型？常用的使用场景"></a>2.Redis有哪些数据类型？常用的使用场景</h2><ol>
<li><strong>String</strong>：存储单个值，适用于<strong>缓存和键值存储</strong>，常用命令:SET用于设置值，GET用于获取值。<ul>
<li><strong>分布式锁、分布式Session、值缓存、对象</strong></li>
</ul>
</li>
<li><strong>List</strong>：有序、可重复的字符串集合，支持从头部或尾部插入&#x2F;删除元素， 适用于<strong>消息队列和发布&#x2F;订阅系统</strong>，常用命令:LPUSH用于从列表左侧添加元素，LRANGE用于获取指定范围的元素。<ul>
<li>分布式Duque、<strong>消息队列</strong>、Push式信息流</li>
</ul>
</li>
<li><strong>Set</strong>：无序、不可重复的字符串集合，适用于<strong>标签系统和好友关系等</strong>，常用命令:SADD用于向集合添加成员，SMEMBERS用于获取集合所有成员。<ul>
<li><strong>聚合计算</strong>（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
</ul>
</li>
<li><strong>Hash</strong>：包含键值对的无序散列表，适用于<strong>存储对象、缓存和计数器</strong>，常用命令:HSET用于设置字段值，HGETALL用于获取散列的所有字段和值。<ul>
<li>对象存储</li>
</ul>
</li>
<li><strong>Zset</strong>：也就是Sorted Set，有序的字符串集合，每个成员关联一个分数，适用于<strong>排行榜和按分数范围获取成员</strong>，常用命令:ZADD用于添加成员及其分数，ZRANGE用于获取指定范围的成员，<ul>
<li><strong>排序场景</strong>，比如排行榜、电话和姓名排序等。</li>
</ul>
</li>
</ol>
<h2 id="3-String还是Hash存储对象更好呢？"><a href="#3-String还是Hash存储对象更好呢？" class="headerlink" title="3.String还是Hash存储对象更好呢？"></a>3.String还是Hash存储对象更好呢？</h2><p><strong>性能</strong></p>
<ul>
<li><strong>String</strong>：适合存储和读取大对象，因为它是整体操作，性能较高。</li>
<li><strong>Hash</strong>：适合操作大量小字段，可以只处理需要的字段，减少不必要的数据传输。</li>
</ul>
<p><strong>内存</strong></p>
<ul>
<li><strong>String</strong>：存储大对象时内存开销可能较大，尤其是对象频繁序列化和反序列化。</li>
<li><strong>Hash</strong>：在存储大量小对象时更节省内存，因为字段共享同一个键名。</li>
</ul>
<p><strong>操作需求</strong></p>
<ul>
<li><strong>String</strong>：如果对象不可变，或者总是整体读写，String更简单。</li>
<li><strong>Hash</strong>：如果需要频繁访问或修改对象的某个字段，Hash更合适。</li>
</ul>
<p>访问粒度上： String 是用一整块内存来存储数据，要进行操作的话都只能全部读取，而 Hash 则可以用基本操作实现单个数据的读取。</p>
<p>更新频率上：频繁改动对象中的少量字段，Hash 类型更好；如果是整体读取而很少写入，String 类型更好。</p>
<p>内存利用上：小字段用 Hash 更方便，大字段整体存取上用 String 更方便。</p>
<h2 id="3-Redis可以用来做什么？"><a href="#3-Redis可以用来做什么？" class="headerlink" title="3.Redis可以用来做什么？"></a><strong>3.Redis可以用来做什么？</strong></h2><ul>
<li>缓存</li>
<li>排行榜</li>
<li>分布式计数器</li>
<li>分布式锁</li>
<li>消息队列</li>
<li>延时队列 </li>
<li>分布式 token</li>
<li>限流</li>
</ul>
<hr>
<h1 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2.持久化"></a>2.持久化</h1><p>什么是持久化？</p>
<p>大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。 Redis 提供两种持久化机制 RDB（默认） 和 AOF 机制: </p>
<h2 id="1-RDB"><a href="#1-RDB" class="headerlink" title="1.RDB"></a>1.RDB</h2><p>RDB：是缩写快照</p>
<p>RDB(Redis DataBase)是Redis默认的持久化方式。将某一时刻的内存数据，以<strong>二进制</strong>的方式写入磁盘； 对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
<p>因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时 ，<strong>需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢</strong>。 为了解决这个问题，Redis 增加了 RDB 快照。 RDB 快照就是记录某一个瞬间的内存数据，<strong>记录的是实际数据</strong></p>
<p>Redis 提供了两个命令来生成 RDB 快照文件： </p>
<ul>
<li><code>save</code>:同步保存操作，会阻塞 Redis 主进程； </li>
<li><code>bgsave</code>:fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<h2 id="2-RDB写时复制（Copy-on-Write）"><a href="#2-RDB写时复制（Copy-on-Write）" class="headerlink" title="2.RDB写时复制（Copy-on-Write）"></a>2.RDB写时复制（Copy-on-Write）</h2><p>假如RDB持久化过程中数据发生了改变怎么办？</p>
<p>在 RDB 快照生成过程中，如果数据发生了改变，Redis 的处理机制可以保证快照的一致性，同时不会丢失后续的修改。具体来说，Redis 使用了一种叫做 <strong>Copy-on-Write（写时复制）</strong> 的技术来解决这个问题。 </p>
<p>先回顾快照的生成过程：</p>
<ul>
<li>当 Redis 触发 RDB 持久化时（比如通过 SAVE 或 BGSAVE 命令），它会创建一个子进程。</li>
<li>子进程负责将内存中的数据写入磁盘，生成 .rdb 文件。</li>
<li>主进程继续处理客户端的请求（比如读写操作）。</li>
</ul>
<p><strong>Copy-on-Write 机制</strong> ：</p>
<ul>
<li>在子进程生成快照时，它会基于某个时间点（触发快照的瞬间）的内存数据进行操作。</li>
<li>如果主进程在这期间修改了数据，操作系统会利用 <strong>写时复制</strong>：<ul>
<li>被修改的数据会被复制一份，主进程在新副本上操作。 </li>
<li>子进程仍然使用原始数据（未修改时的内存快照）生成快照。</li>
</ul>
</li>
<li>这样，主进程的修改不会影响子进程正在生成的快照，快照仍然是触发时刻的一致性数据。</li>
</ul>
<p><strong>数据丢失风险</strong>：快照生成后到下一次快照之间的修改，如果没来得及保存（比如 Redis 崩溃），会丢失。 </p>
<h2 id="3-AOF"><a href="#3-AOF" class="headerlink" title="3.AOF"></a>3.AOF</h2><p>AOF持久化(即Append Only File)，Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里， 然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。 </p>
<blockquote>
<p>AOF为什么是在执行完写命令才将该命令记录到AOF日志？</p>
</blockquote>
<ol>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ol>
<p>潜在风险</p>
<ol>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的，也就是说这两个操作是<strong>同步</strong>的，如果在将日志内容写入到硬盘时，服务器的硬盘的 I&#x2F;O 压力太大，就会导致写硬盘的速度很慢， 进而阻塞住了，也就会导致后续的命令无法执行。</li>
</ol>
<p><img src="https://pic1.imgdb.cn/item/677bacc6d0e0a243d4efe124.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/677bacc6d0e0a243d4efe124.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="AOF一条"></p>
<ul>
<li>优点：首先，AOF提供了更好的数据安全性，因为它默认每接收到一个写命令就会追加到文件末尾。 即使Redis服务器宕机，也只会丢失最后一次写入前的数据。 </li>
<li>缺点：因为记录了每一个写操作，所以AOF文件通常比RDB文件更大，<strong>消耗更多的磁盘空间</strong>。</li>
</ul>
<p>总结：RDB是Redis的快照持久化方式，通过<strong>周期性</strong>的快照将数据保存到硬盘，占用更少的磁盘空间和 CPU资源，适用于数据备份和恢复，但可能存在数据丢失的风险。AOF 是追加日志持久化方式，将每个写操作以追加的方式记录到日志文件中，确保了更高的数据完整性和持久性，但相对于RDB 消耗更多的磁盘空间和写入性能，适用于数据持久化和灾难恢复，且可以通过配置实现不同的同步频率。</p>
<h2 id="4-AOF三种写回策略"><a href="#4-AOF三种写回策略" class="headerlink" title="4.AOF三种写回策略"></a>4.AOF三种写回策略</h2><p>Redis 写入 AOF 日志的过程，如下图： </p>
<p><img src="https://pic1.imgdb.cn/item/68b7e0cb58cb8da5c8767a70.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/68b7e0cb58cb8da5c8767a70.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 <code>server.aof_buf</code> 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件， 此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache， 等待内核将数据写入硬盘； </li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 </p>
<ol>
<li><strong>always</strong>：<strong>理论上不会丢失任何数据</strong>。每个写命令都会同步刷盘后再返回给客户端。这是最安全的方式，但<strong>性能开销巨大</strong>，会严重降低 Redis 的吞吐量，通常不推荐在生产环境使用。 </li>
<li><strong>everysec</strong>：<strong>可能丢失最多1秒的数据</strong>。这是默认配置，也是性能和安全的良好折衷。后台线程每秒执行一次刷盘。如果刚好在刷盘间隔内（1秒钟）发生宕机，就会丢失这1秒内的写命令。 </li>
<li>no：<strong>可能丢失最多数据</strong>。写入操作由操作系统内核决定何时刷到磁盘，通常间隔长达30秒。如果 Redis 进程或服务器在这30秒内宕机，这期间的所有命令都会丢失。</li>
</ol>
<p><img src="https://pic1.imgdb.cn/item/68b7e74d58cb8da5c8768e21.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/68b7e74d58cb8da5c8768e21.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>从上图可以看出，数据丢失发生在命令写入<strong>内存缓冲区 (aof_buf)</strong> 后，到真正<strong>写入磁盘</strong>前的这个时间窗口内。如果发生宕机，这个缓冲区中的数据就会丢失。 </p>
<p><strong>真正的“零丢失”方案：</strong> 单机 Redis 无法保证绝对的数据不丢失。真正的生产环境高可用方案是：</p>
<ul>
<li>**主从复制 (Replication)**：配置一个从节点 (replica)，主节点的数据会异步复制到从节点。如果主节点宕机，可以手动或通过哨兵&#x2F;集群模式切换到从节点。</li>
<li><strong>结合使用 AOF 和 RDB</strong>：你可以同时开启 RDB 和 AOF。RDB 用于做定时快照和快速恢复，AOF 用于保证数据完整性。在重启时，Redis 会优先使用 AOF 来恢复，因为它通常更完整。</li>
</ul>
<h2 id="5-AOF重写机制"><a href="#5-AOF重写机制" class="headerlink" title="5.AOF重写机制"></a>5.AOF重写机制</h2><p><strong>问题：</strong> AOF 文件记录的是每个写命令，随着时间推移，文件会越来越大。例如，一个计数器被递增了100次，AOF 文件会记录100条 <code>INCR</code> 命令，但实际上只需要一条 <code>SET key 100</code> 命令就能恢复最终状态。</p>
<p><strong>解决方案：AOF 重写 (Rewriting)</strong><br>AOF 重写会创建一个新的、更紧凑的 AOF 文件来替换原有的庞大文件。<strong>新文件只包含恢复当前数据集所需的最小命令集合</strong>，它通过读取当前数据库中的键值对来实现，而不是分析旧的 AOF 文件。</p>
<p>“AOF 重写是 Redis 为了解决 AOF 文件体积膨胀问题而设计的机制。它的<strong>核心目的是创建一个新的、更小的 AOF 文件，这个文件包含了重建当前数据库状态所需的最少命令集合</strong>。”</p>
<p>它的工作原理和过程是这样的：</p>
<ol>
<li><strong>触发方式</strong>：<ul>
<li><strong>自动触发</strong>：通过在 <code>redis.conf</code> 中配置 <code>auto-aof-rewrite-percentage</code>（增长比例）和 <code>auto-aof-rewrite-min-size</code>（最小体积）来触发。</li>
<li><strong>手动触发</strong>：通过调用 <code>BGREWRITEAOF</code> 命令。</li>
</ul>
</li>
<li><strong>执行过程</strong>：<ul>
<li>重写是通过 <strong>fork() 出一个子进程</strong>来完成的，这保证了主进程可以继续处理命令，不会阻塞。</li>
<li>子进程遍历当前数据库中的所有数据，根据值的类型（字符串、列表、哈希等）将每个键值对<strong>转换并写入一条最精简的命令</strong>到新的临时 AOF 文件中。</li>
<li><strong>与此同时</strong>，主进程接收到的新写命令不仅会写入原有的 AOF 缓冲区，还会<strong>写入一个专门的 AOF 重写缓冲区</strong>。这样就能保证即使重写期间有新数据，也不会丢失。</li>
</ul>
</li>
<li><strong>收尾工作</strong>：<ul>
<li>当子进程完成重写后，会向主进程发送一个信号。</li>
<li>主进程收到信号后，会将 <strong>AOF 重写缓冲区</strong> 中的所有命令追加到新的临时 AOF 文件中，确保数据完整性。</li>
<li>最后，主进程会<strong>原子性地用新的 AOF 文件替换掉旧的 AOF 文件</strong>。至此，重写过程完成。</li>
</ul>
</li>
</ol>
<p><strong>总结一下，AOF 重写的优点在于：</strong></p>
<ul>
<li><strong>大幅减小磁盘占用量</strong>。</li>
<li><strong>提升恢复速度</strong>（因为要回放的命令变少了）。</li>
<li><strong>整个过程是非阻塞的</strong>（除了 <code>fork()</code> 瞬间的延迟），主进程可以持续服务。</li>
</ul>
<p><strong>核心</strong>：<strong>“子进程做快照，双缓冲区保数据”</strong> </p>
<p><img src="https://pic1.imgdb.cn/item/68b7eb1158cb8da5c8769a44.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/68b7eb1158cb8da5c8769a44.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p> 面试可能遇到的其他问题：</p>
<ol>
<li><strong>重写过程中如果失败怎么办？</strong><ul>
<li>如果重写失败（例如，子进程出错或磁盘已满），旧的 AOF 文件不会被替换，Redis 会继续使用旧的文件，并在日志中记录错误。整个过程对客户端是无感知的。</li>
</ul>
</li>
<li><strong>fork() 操作会阻塞吗？</strong><ul>
<li>虽然 <code>fork()</code> 操作本身是阻塞的，但由于 Redis 使用了操作系统的写时复制（Copy-on-Write, COW）技术，<code>fork()</code> 的执行时间通常非常快，除非数据集非常大。但如果机器内存不足或数据集巨大，<code>fork()</code> 延迟可能会成为一个问题。</li>
</ul>
</li>
<li><strong>AOF 重写和 RDB 快照的 fork() 有什么区别？</strong><ul>
<li>它们的 <code>fork()</code> 机制在原理上是一样的。都是通过创建子进程来利用 COW 机制，避免阻塞主进程。区别在于：<ul>
<li><strong>RDB</strong>：子进程将整个数据库的快照写入一个二进制文件（<code>.rdb</code>）。</li>
<li><strong>AOF重写</strong>：子进程将数据库转换为重建所需的最小命令集，写入一个新的文本文件（<code>.aof</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>和 RDB 相比，AOF 重写的优势？</strong><ul>
<li><strong>AOF 重写</strong> 是一个<strong>增量式的整理过程</strong>，它不会像 RDB 快照那样产生一个全量备份。它生成的仍然是一个可追加的日志文件，<strong>保证了 AOF 本身的实时性和连续性</strong>。而 RDB 是某一时间点的全量快照。</li>
</ul>
</li>
</ol>
<h2 id="6-如何选择"><a href="#6-如何选择" class="headerlink" title="6.如何选择"></a>6.如何选择</h2><p>1.RDB</p>
<p>缺点：周期性保存快照，但如果下次快照前宕机，会<strong>丢失数据很多</strong></p>
<p>优点：保存的是原始数据，<strong>恢复起来比AOF更快</strong>（因为AOF保存的是命令还要执行）；<strong>文件小</strong>，适合做数据的备份，灾难恢复。 </p>
<p>2.AOF</p>
<p>缺点：恢复慢</p>
<p>优点：<strong>数据更加完整</strong>（即使Redis服务器宕机，也只会丢失最后一次写入前的数据）</p>
<p><strong>建议开启混合模式</strong></p>
<p>当开启了混合持久化时，在 AOF 重写日志时， fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，</strong> <strong>后半部分是 AOF 格式的增量数据</strong>。 </p>
<p><img src="https://pic1.imgdb.cn/item/68b7ec1858cb8da5c8769aec.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/68b7ec1858cb8da5c8769aec.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>这样的好处在于，重启 Redis 加载数据的时候， 由于前半部分是 RDB 内容，这样<strong>加载的时候速度会很快</strong>。 </p>
<p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容， 这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令， 可以使得<strong>数据更少的丢失</strong>。 </p>
<hr>
<h1 id="3-Redis内存管理"><a href="#3-Redis内存管理" class="headerlink" title="3.Redis内存管理"></a>3.Redis内存管理</h1><h2 id="1-过期键的删除策略有哪些"><a href="#1-过期键的删除策略有哪些" class="headerlink" title="1.过期键的删除策略有哪些"></a>1.过期键的删除策略有哪些</h2><ul>
<li><strong>定时过期（CPU不友好，内存友好）</strong>：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li><strong>惰性过期（CPU友好，内存不友好）</strong>：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li><strong>定期过期（前两种的折中）</strong>：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。</li>
</ul>
<blockquote>
<p>Redis key的过期时间和永久有效分别怎么设置</p>
</blockquote>
<p>expire命令和persist命令</p>
<h2 id="2-内存淘汰粗略有哪些"><a href="#2-内存淘汰粗略有哪些" class="headerlink" title="2.内存淘汰粗略有哪些"></a>2.内存淘汰粗略有哪些</h2><blockquote>
<p><strong>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p>
</blockquote>
<p>redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><strong>全局的键空间选择性移除</strong></p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是<strong>最常用</strong>的）</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
</ul>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，挑选将要过期的数据淘汰。</li>
</ul>
<hr>
<h1 id="4-缓存篇"><a href="#4-缓存篇" class="headerlink" title="4.缓存篇"></a>4.缓存篇</h1><h2 id="1-缓存一致性方案"><a href="#1-缓存一致性方案" class="headerlink" title="1.缓存一致性方案"></a>1.缓存一致性方案</h2><blockquote>
<p>1、<strong>Cache Aside Pattern</strong> （旁路缓存模式，双写模式）</p>
</blockquote>
<p>对于<strong>读</strong>：从缓存中读取，如果读不到，就从数据库中读取，并把这个数据写入缓存</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-read.png" class="lazyload" data-srcset="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-read.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双写读"></p>
<p>对于<strong>写</strong>：先更新数据库，然后直接删除缓存</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png" class="lazyload" data-srcset="https://oss.javaguide.cn/github/javaguide/database/redis/cache-aside-write.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双写写"></p>
<ol>
<li><p>为什么不是采用更新缓存模式，而是采用删除缓存？</p>
<p>答：可能会造成<strong>无效写操作</strong>。如果更新的缓存很多，但这期间并没有查询操作，就造成了无效的写操作</p>
</li>
<li><p>为什么先更新数据库，而不是先删除缓存，再更新数据库？</p>
<p>答：因为<strong>数据不一致</strong>。写线程A删除了缓存，但还没来得及更新数据库，此时，读线程B未命中缓存，去数据库读取旧数据，并写入缓存返回了，然后线程A更新了数据库中的数据，此时就数据不一致了。在这个过程中，<strong>写线程更新数据库的时间都比读线程读数据库+写回Redis的时间长</strong>了，所以非常有可能发生数据不一致</p>
<p><img src="https://pic1.imgdb.cn/item/67d93ab688c538a9b5c038e1.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/67d93ab688c538a9b5c038e1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="为什么先删缓存不行"></p>
</li>
<li><p>采用先更新数据库，再删除缓存就没有问题了吗？</p>
<p>答：也有可能会有问题，但概率会小的多！只有这种恰巧的情况：读线程读的时候<strong>缓存失效</strong>了，而且就在它访问完数据库之后，准备写回缓存之前，这是<strong>写线程一口气执行完了更新数据库和删缓存</strong>这两个操作，然后读线程把旧的数据写回了缓存。但这种可能性很低，因为一般来说更新数据库是非常耗时的。</p>
</li>
<li><p>问题3如何解决？</p>
<p>答：<strong>延迟双删</strong>。在读线程把旧数据写回缓存后，然后写线程隔一小段时间再把这个缓存给删了，就是写线程要删除两次缓存。或者<strong>消息队列</strong>（TODO）</p>
</li>
</ol>
<blockquote>
<p>2、Read&#x2F;Write Through Pattern（读写穿透，直写缓存模式 ，写穿）</p>
</blockquote>
<p><strong>在此模式下，所有写操作都会先更新缓存，然后再同步更新数据库。</strong> </p>
<p>对于读：从缓存中读取，如果读不到，从数据库中读取，然后写回cache后再返回（<strong>和双写模式一样</strong>）</p>
<p>对于写：先查缓存，缓存中没有就直接更新数据库，缓存中有，先更新缓存，再接着更新数据库。</p>
<blockquote>
<p>3、Write behind Pattern（异步缓存写入，异步写）</p>
</blockquote>
<p><strong>写操作只更新缓存，不立即同步到数据库，而是延迟批量更新数据库。</strong> </p>
<p>对于读：<strong>和双写模式一样</strong></p>
<p>对于写：只更新缓存，然后异步的更新数据库，可以将更新数据库的任务交给消息队列或者线程池</p>
<p><strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong> </p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<p><strong>三种模式比较</strong></p>
<p>三者读性能一样的，主要区别就是写性能</p>
<p>旁路缓存模式：高并发场景可能存在短暂数据不一致。适合读操作频繁、写操作较少且数据一致性要求高的场景，例如用户信息、<strong>商品详情查询</strong>等。</p>
<p>写穿模式：写入最慢，一致性最好。适合数据一致性要求较高的场景，例如金融交易系统。</p>
<p>异步写模式：写入最快，一致性最差。适合写操作频繁、对一致性要求不高且容忍一定延迟的场景，例如日志系统、计数统计等。</p>
<h2 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2.缓存穿透"></a>2.缓存穿透</h2><p><strong>缓存和数据库中都没有用户要访问的数据</strong>，当有大量这样的请求到来时，数据库的压力骤增 ，造成数据库短时间内承受大量请求而崩掉。 </p>
<p>解决方案：</p>
<ul>
<li><strong>非法请求的限制：</strong>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在， 如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。 </li>
<li><strong>缓存空值或者默认值：</strong>当我们线上业务发现缓存穿透的现象时，可以针对查询的数据， 在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值， 返回给应用，而不会继续查询数据库。 这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。 </li>
<li><strong>布隆过滤器：</strong>我们可以在写入数据库数据时，使用布隆过滤器做个标记， 然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在， 如果不存在，就不用通过查询数据库来判断数据是否存在。即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行</li>
</ul>
<h2 id="3-布隆过滤器"><a href="#3-布隆过滤器" class="headerlink" title="3.布隆过滤器"></a>3.布隆过滤器</h2><ol>
<li><h3 id="一、核心概念：它是什么？"><a href="#一、核心概念：它是什么？" class="headerlink" title="一、核心概念：它是什么？"></a>一、核心概念：它是什么？</h3><p><strong>布隆过滤器本质上是一个很长的二进制向量（位数组）和一系列随机映射函数（哈希函数）。</strong></p>
<p>它的主要作用是：<strong>以极小的空间开销，快速判断一个元素“一定不存在”或“可能存在”于某个集合中。</strong></p>
<p>注意这两个关键词：</p>
<ul>
<li><strong>一定不存在</strong>：这个判断是<strong>绝对准确</strong>的。</li>
<li><strong>可能存在</strong>：这个判断有<strong>一定的误判率</strong>。</li>
</ul>
<hr>
<h3 id="二、工作原理（它是如何工作的？）"><a href="#二、工作原理（它是如何工作的？）" class="headerlink" title="二、工作原理（它是如何工作的？）"></a>二、工作原理（它是如何工作的？）</h3><p>布隆过滤器的操作分为两部分：<strong>添加元素</strong>和<strong>查询元素</strong>。</p>
<h4 id="1-添加元素-Add"><a href="#1-添加元素-Add" class="headerlink" title="1. 添加元素 (Add)"></a>1. 添加元素 (Add)</h4><p>当一个元素被加入过滤器时，会进行以下操作：</p>
<ol>
<li>使用 <code>k</code> 个不同的哈希函数对这个元素进行计算，得到 <code>k</code> 个哈希值。</li>
<li>将这些哈希值映射到位数组的对应位置上，并将这些位置<strong>置为 1</strong>。</li>
</ol>
<h4 id="2-查询元素-Check"><a href="#2-查询元素-Check" class="headerlink" title="2. 查询元素 (Check)"></a>2. 查询元素 (Check)</h4><p>当要检查一个元素是否存在于过滤器中时：</p>
<ol>
<li>同样使用那 <code>k</code> 个哈希函数对元素进行计算，得到 <code>k</code> 个哈希值。</li>
<li>检查位数组中这些对应的位置：<ul>
<li><strong>如果其中有任何一个位置的值为 0</strong>，那么这个元素<strong>一定不存在</strong>于集合中。</li>
<li><strong>如果所有位置的值都是 1</strong>，那么这个元素<strong>很可能存在</strong>于集合中（但存在误判的可能）。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>三、优缺点</strong></p>
<p>优点：</p>
<ol>
<li><strong>空间效率极高</strong>：不需要存储元素本身，只需要一个位数组，远超其他数据结构。</li>
<li><strong>查询时间极快</strong>：查询时间都是常数时间 <code>O(k)</code>，与集合大小无关。</li>
<li><strong>保密性强</strong>：因为它不存储原始数据，对数据有安全保护作用。</li>
</ol>
<p>缺点：</p>
<ol>
<li>**存在误判率 (False Positive)**：这是最大的缺点。判断“存在”时可能是错的，但判断“不存在”一定是正确的。</li>
<li><strong>无法删除元素</strong>：因为一个位可能被多个元素共享，直接将某位置 <code>0</code> 会导致其他元素被误删。（但可以通过<strong>计数布隆过滤器</strong>变种解决，用计数器代替位）</li>
<li><strong>不支持扩容</strong>：一旦位数组长度初始化后，无法动态扩展。</li>
</ol>
<p><strong>你可以这样回答：</strong></p>
<blockquote>
<p>“布隆过滤器是一个使用位数组和多个哈希函数来实现的概率型数据结构。它的核心作用是<strong>高效地判断一个元素是否一定不存在或者可能存在一个集合里</strong>。</p>
<p>它的<strong>优点是空间效率和查询时间都极高</strong>，但缺点是<strong>有误判率</strong>，并且<strong>无法删除元素</strong>。</p>
<p>它的经典应用场景是解决<strong>缓存穿透</strong>问题。在请求到来时，先问布隆过滤器这个数据存不存在，如果过滤器说不存在，我们就直接返回，避免了无效的数据库查询，保护了后端资源。</p>
<p>另外，像爬虫URL去重、垃圾邮件过滤这些需要大规模数据判断但又可以容忍极小误差的场景，也非常适合用它。</p>
<p>需要注意的是，布隆过滤器的误判率可以通过调整位数组大小和哈希函数数量来控制，在实际使用中我们需要根据业务场景来权衡空间和误判率。”</p>
</blockquote>
<h2 id="4-缓存击穿"><a href="#4-缓存击穿" class="headerlink" title="4.缓存击穿"></a>4.缓存击穿</h2><p>指<strong>某个热点数据在缓存中过期时，大量并发请求直接穿透到数据库</strong>，导致数据库瞬时压力激增甚至崩溃。</p>
<p>解决方案：</p>
<ul>
<li><p><strong>互斥锁方案（</strong>看情况）：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求， 要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。 </p>
</li>
<li><p><strong>永不过期</strong>（不推荐）：缓存永不过期，但存储一个过期时间字段，异步更新。</p>
</li>
<li><p><strong>提前预热</strong>（推荐）：在缓存过期前主动刷新热点数据。</p>
<ul>
<li><p><strong>实现方式</strong>：</p>
<p>定时任务：通过 Quartz 或 Spring Scheduler 定期触发加载。</p>
<p>事件驱动：监听数据变更消息（如 Binlog + Canal）自动更新缓存。</p>
</li>
</ul>
</li>
<li><p><strong>二级缓存（Multi-Level Cache）</strong></p>
<p><strong>核心思想</strong>：本地缓存（如 Caffeine） + 分布式缓存（Redis）分层拦截。</p>
</li>
<li><p><strong>限流降级（Rate Limiting）</strong></p>
<p><strong>核心思想</strong>：当缓存失效时，限制数据库访问的并发量。</p>
</li>
</ul>
<p><strong>方案对比总结</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>方案</strong></th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>互斥锁</strong></td>
<td align="left">强一致性</td>
<td align="left">锁竞争可能成瓶颈</td>
<td align="left">数据变更少，重建成本高</td>
</tr>
<tr>
<td align="left"><strong>逻辑过期</strong></td>
<td align="left">高吞吐，无阻塞</td>
<td align="left">短暂数据不一致</td>
<td align="left">允许最终一致的热点数据</td>
</tr>
<tr>
<td align="left"><strong>缓存预热</strong></td>
<td align="left">避免突发流量</td>
<td align="left">依赖预测准确性</td>
<td align="left">可预知的热点（如大促商品）</td>
</tr>
<tr>
<td align="left"><strong>二级缓存</strong></td>
<td align="left">减少Redis压力</td>
<td align="left">本地缓存一致性难维护</td>
<td align="left">高频访问的静态数据</td>
</tr>
<tr>
<td align="left"><strong>限流降级</strong></td>
<td align="left">保护数据库</td>
<td align="left">用户体验下降（降级）</td>
<td align="left">突发流量且允许部分失败</td>
</tr>
</tbody></table>
<h2 id="5-缓存雪崩"><a href="#5-缓存雪崩" class="headerlink" title="5.缓存雪崩"></a>5.缓存雪崩</h2><p>当<strong>大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机</strong>时，如果此时有大量的用户请求， 都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增， 严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃， </p>
<p>解决方案：</p>
<p><strong>针对 Redis 服务不可用的情况：</strong> </p>
<ol>
<li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案 </li>
<li><strong>多级缓存</strong>：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li>
</ol>
<p><strong>针对大量缓存同时失效的情况：</strong> </p>
<ul>
<li><strong>设置随机失效时间</strong>（可选）：为缓存设置随机的失效时间， 这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。 </li>
<li><strong>提前预热</strong>（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>设置缓存锁:在缓存失效时，设置一个短暂的锁定时间，只允许一个请求查询数据库并刷新缓存，其他请求等待锁释放后再读取缓存。</li>
</ul>
<h2 id="6-大Key问题"><a href="#6-大Key问题" class="headerlink" title="6.大Key问题"></a>6.大Key问题</h2><blockquote>
<p>一、什么是大 Key？（是什么？）</p>
</blockquote>
<p>大 Key 通常指的是一个 Key 对应的 Value 值非常大，或者是一个集合类型（Hash, List, Set, Sorted Set, Stream）中元素数量过多。</p>
<p><strong>常见的衡量标准（面试时可以说）：</strong></p>
<ul>
<li><strong>String 类型</strong>：<code>value &gt; 10 KB</code></li>
<li><strong>集合类型</strong>：<code>元素数量 &gt; 10000</code><ul>
<li>一个 Hash 有 10000 个 field</li>
<li>一个 List 有 10000 个元素</li>
<li>一个 Set&#x2F;ZSet 有 10000 个成员</li>
</ul>
</li>
</ul>
<p><em>(注意：这个标准不是绝对的，需要根据实际业务和服务器配置来定，但面试时给出一个具体数字能体现你的经验)</em></p>
<blockquote>
<p>二、大 Key 会带来什么问题？（为什么？）</p>
</blockquote>
<p>这是回答的重点，要清晰地说明大 Key 对性能、稳定性等多个维度的负面影响。</p>
<p><strong>你可以从以下四个角度阐述：</strong></p>
<ol>
<li><strong>性能瓶颈</strong><ul>
<li><strong>操作延迟高</strong>：读写一个几百KB的String，或者获取一个上万元素的List全部内容（<code>LRANGE key 0 -1</code>），会非常耗时，容易阻塞后续命令。</li>
<li><strong>网络阻塞</strong>：一次查询大Key会占用大量带宽，影响其他请求的传输。</li>
</ul>
</li>
<li><strong>数据倾斜</strong><ul>
<li>在 Redis 集群模式下，数据会通过分片分布在不同的节点上。但一个大 Key 无法被拆分，<strong>会导致某个节点的数据量远大于其他节点</strong>。该节点内存不足、CPU压力大，成为整个集群的瓶颈。</li>
</ul>
</li>
<li><strong>阻塞风险</strong><ul>
<li>Redis 是<strong>单线程</strong>处理命令的。如果使用 <code>DEL</code> 命令删除一个非常大的 Key（例如一个包含百万元素的Hash），这个删除操作会长时间占用主线程，导致 Redis 服务<strong>完全阻塞</strong>，所有其他请求都会超时。</li>
<li>同样，对大 Key 的持久化（<code>BGSAVE</code>、<code>BGREWRITEAOF</code>）时，<code>fork()</code> 子进程的过程可能会因为复制巨大的内存页表而变慢，导致主进程短暂阻塞。</li>
</ul>
</li>
<li><strong>内存浪费与碎片</strong><ul>
<li>大 Key 的扩容可能不高效，容易产生内存碎片。</li>
<li>如果对大 Key 频繁修改，可能会触发内存页复制，消耗更多 CPU。</li>
<li>大Key占用过多的内存空间，可能导致可用内存不足， 从而触发内存淘汰策略。在极端情况下， 可能导致内存耗尽，Redis实例崩溃，影响系统的稳定性。</li>
</ul>
</li>
</ol>
<blockquote>
<p>三、如何发现大 Key？（怎么找？）</p>
</blockquote>
<p><strong>1. 使用官方工具 redis-cli –bigkeys</strong></p>
<ul>
<li>这是一个扫描工具，会快速找到每种数据类型中最大的 Key。</li>
<li><strong>优点</strong>：简单、快速、无需额外工具。</li>
<li><strong>缺点</strong>：只能返回每种类型的一个最大Key，且统计的是<code>value</code>的大小而非<code>key</code>本身的大小，对于集合类型是统计元素个数。</li>
</ul>
<p><strong>2. 使用 memory usage 命令</strong></p>
<ul>
<li>对于可疑的 Key，可以用这个命令来精确查询它实际占用的字节数。</li>
<li><code>MEMORY USAGE your_key_name</code></li>
</ul>
<p><strong>3. 使用第三方工具</strong></p>
<ul>
<li>一些开源工具如 <code>rdb-tools</code>，可以离线分析 RDB 快照文件，生成所有 Key 的大小报告，非常全面准确。</li>
</ul>
<p><strong>4. 监控与告警</strong></p>
<ul>
<li>通过 <code>info memory</code>、<code>slowlog</code> 等命令进行监控，如果发现内存激增或慢查询中有操作大Key的痕迹，及时告警。</li>
</ul>
<blockquote>
<p>四、如何解决和处理大 Key？（怎么办？）</p>
</blockquote>
<p>这是体现你解决方案能力的关键。</p>
<p><strong>1. 拆分（最根本的解决方案）</strong></p>
<ul>
<li><strong>String 大 Key</strong>：如果value很大且逻辑上可拆分，比如一个大JSON，可以拆分成多个小Key，用 <code>MSET</code>&#x2F;<code>MGET</code> 来批量操作。</li>
<li><strong>集合大 Key</strong>：<ul>
<li><strong>Hash</strong>：可以按 field 的规则进行拆分。例如，用户数据 <code>user:1000:info</code> 有1万个field，可以拆分成 <code>user:1000:info:1</code>、<code>user:1000:info:2</code> … 每个Hash存1000个field。</li>
<li><strong>List&#x2F;Set&#x2F;ZSet</strong>：可以按元素范围或规则拆分。例如，一个大的消息列表 <code>user:1000:messages</code>，可以按时间拆分成 <code>user:1000:messages:202310</code>、<code>user:1000:messages:202311</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 删除（如何安全地删除？）</strong><br><strong>千万不要直接使用 DEL！</strong></p>
<ul>
<li>对于<strong>集合类型</strong>的大Key，使用对应的渐进式删除命令：<ul>
<li><strong>Hash</strong>: <code>HSCAN</code> + <code>HDEL</code>（先遍历，再分批删除）</li>
<li><strong>Set</strong>: <code>SSCAN</code> + <code>SREM</code></li>
<li><strong>List</strong>: 直接 <code>LTRIM key 0 99</code>（逐步修剪，只保留最新100个）</li>
<li><strong>ZSet</strong>: <code>ZSCAN</code> + <code>ZREM</code></li>
</ul>
</li>
<li>对于<strong>任何类型</strong>，在 Redis 4.0+ 版本中，可以使用<strong>异步删除命令 UNLINK</strong>。<code>UNLINK</code> 会将 Key 从 keyspace 中立即移除，真正的内存释放会在后台异步进行，<strong>不会阻塞主线程</strong>。</li>
</ul>
<p><strong>3. 优化数据结构</strong></p>
<ul>
<li>思考是否可以用更高效的数据结构。例如，统计用户签到，用 String 类型做位图（<code>SETBIT</code>）远比用 Set 类型存储每天的日期节省空间。</li>
</ul>
<p><strong>4. 从设计上避免</strong></p>
<ul>
<li>这是最重要的。在业务设计阶段，就要避免产生大Key。建立代码规范，在写入Redis时就要判断Value大小或元素数量是否可能膨胀。</li>
</ul>
<blockquote>
<p>五、面试回答总结（精简版）</p>
</blockquote>
<p>“大Key主要是指Value过大或元素过多的Key。它主要会带来<strong>四个问题</strong>：一是<strong>操作耗时</strong>，导致慢查询；二是<strong>数据倾斜</strong>，影响集群均衡；三是<strong>阻塞风险</strong>，<code>DEL</code>删除或持久化时可能卡住整个服务；四是<strong>内存浪费</strong>。</p>
<p>我们可以用 <code>redis-cli --bigkeys</code> 或 <code>memory usage</code> 来定位它。</p>
<p>处理上，<strong>核心思路是拆分和异步删除</strong>：</p>
<ul>
<li><strong>拆分</strong>：把一个大Hash拆成多个小Hash，一个大List拆成多个时间段的List。</li>
<li><strong>删除</strong>：绝对不用 <code>DEL</code>，而是用 <code>HSCAN</code>+<code>HDEL</code> 这类渐进式命令，或者直接用Redis 4.0提供的<strong>异步删除命令 UNLINK</strong>，这是最安全高效的方式。</li>
</ul>
<p>当然，最好的办法还是在设计之初就通过规范来避免产生大Key。”</p>
<p>这样的回答，既全面又层次分明，一定能给面试官留下好印象。</p>
<h2 id="7-Redis大key如何影响持久化"><a href="#7-Redis大key如何影响持久化" class="headerlink" title="7.Redis大key如何影响持久化"></a>7.Redis大key如何影响持久化</h2><p><strong>对于AOF日志的影响</strong></p>
<ul>
<li><strong>当使用 Always 策略的时候，如果写入是一个大 Key，</strong> <strong>主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，</strong> <strong>因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</strong>。 </li>
<li>当使用 Everysec 策略的时候，由于是异步执行 fsync0 函数，所以大 Key 持久化的过程(数据同步磁盘)不会影响主线程。</li>
<li>当使用 No 策略的时候，由于永不执行 fsync( 函数，所以大 Key 持久化的过程不会影响主线程。</li>
</ul>
<p><strong>对于AOF重写和RDB的影响</strong></p>
<p>当 AOF 日志写入了很多的大 Key，AOF 日志文件的大小会很大， 那么很快就会触发 <strong>AOF 重写机制</strong>。 </p>
<p>AOF 重写机制和 RDB 快照（bgsave 命令）的过程， 都会分别通过 <code>fork()</code> 函数创建一个子进程来处理任务。 </p>
<p>在创建子进程的过程中，操作系统会把父进程的「页表」复制一份给子进程，这个页表记录着虚拟地址和物理地址映射关系，而不会复制物理内存，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个</p>
<p><img src="https://pic1.imgdb.cn/item/68b7f42858cb8da5c876ad48.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/68b7f42858cb8da5c876ad48.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>这样一来，子进程就共享了父进程的物理内存数据了，这样能够节约物理内存资源， 页表对应的页表项的属性会标记该物理内存的权限为<strong>只读</strong>。 </p>
<p>随着 Redis 存在越来越多的大 Key，那么 Redis 就会占用很多内存， 对应的页表就会越大。 </p>
<p>在通过 <code>fork()</code> 函数创建子进程的时候，虽然不会复制父进程的物理内存， 但是<strong>内核会把父进程的页表复制一份给子进程，如果页表很大，</strong> <strong>那么这个复制过程是会很耗时的，那么在执行 fork 函数的时候就会发生阻塞现象</strong>。 </p>
<p>而且，fork 函数是由 Redis 主线程调用的，如果 fork 函数发生阻塞， 那么意味着就会阻塞 Redis 主线程。 </p>
<blockquote>
<p>什么时候会发生物理内存复制呢？</p>
</blockquote>
<p>当父进程或者子进程在向共享内存发起写操作时，CPU 就会触发<strong>写保护中断</strong>， 这个「写保护中断」是由于违反权限导致的， 然后操作系统会在「写保护中断处理函数」里进行物理内存的复制，并重新设置其内存映射关系， 将父子进程的内存读写权限设置为可读写，最后才会对内存进行写操作， 这个过程被称为「**写时复制(Copy On Write)**」。 </p>
<p><img src="https://pic1.imgdb.cn/item/68b7f49758cb8da5c876ae6d.png" class="lazyload" data-srcset="https://pic1.imgdb.cn/item/68b7f49758cb8da5c876ae6d.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>如果创建完子进程后，<strong>父进程对共享内存中的大 Key 进行了修改，</strong> <strong>那么内核就会发生写时复制，会把物理内存复制一份，</strong> <strong>由于大 Key 占用的物理内存是比较大的，那么在复制物理内存这一过程中，</strong> <strong>也是比较耗时的，于是父进程（主线程）就会发生阻塞</strong>。 </p>
<p>总结：</p>
<p>当 AOF 写回策略配置了 Always 策略，如果写入是一个大 Key，主线程在执行 fsync0 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的。</p>
<p>AOF 重写机制和 RDB 快照(bgsave 命令)的过程，都会分别通过 fork()函数创建一个子进程来处理任务。会有两个阶段会导致阻塞父进程(主线程):</p>
<ol>
<li>创建子进程的途中，由于要复制父进程的页表等数据结构， 阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长； </li>
<li>创建完子进程后，如果父进程修改了共享数据中的大 Key， 就会发生写时复制，这期间会拷贝物理内存， 由于大 Key 占用的物理内存会很大，那么在复制物理内存这一过程，就会比较耗时，所以有可能会阻塞父进程。</li>
</ol>
<h2 id="8-热Key"><a href="#8-热Key" class="headerlink" title="8.热Key"></a>8.热Key</h2><blockquote>
<p>一、什么是热 Key？</p>
</blockquote>
<p><strong>热 Key</strong>（Hot Key）是指<strong>在 Redis 中，某个 Key 在短时间内被极其高频地访问</strong>，其访问量远远超过了其他 Key。</p>
<p>例如：</p>
<ul>
<li>某个明星突然宣布离婚，其微博主页的缓存 Key 可能瞬间被每秒访问上百万次。</li>
<li>电商平台中，某个参与秒杀活动的热门商品详情页的 Key。</li>
<li>新闻App中，一条突发新闻的缓存 Key。</li>
</ul>
<p>当一个 Key 成为热 Key 时，它就不再是一个简单的数据，而变成了整个系统的<strong>瓶颈点</strong>。</p>
<blockquote>
<p>二、热 Key 会带来什么问题？</p>
</blockquote>
<p>热 Key 的危害是巨大且连锁的，主要体现在以下四个方面：</p>
<p><strong>1. 流量集中，打爆 Redis 单节点性能瓶颈</strong></p>
<ul>
<li>Redis 是单线程模型（处理命令的主线程），单个节点的处理能力有上限。</li>
<li>所有针对同一个 Key 的请求都必须由同一个节点处理（在集群模式下，一个 Key 只存在于一个节点）。这会导致该节点的 <strong>CPU 负载飙升</strong>，达到 100%，无法处理更多请求。</li>
<li>即使 Redis 是集群模式，也无法分摊同一个 Key 的访问压力。</li>
</ul>
<p><strong>2. 带宽占满，影响其他服务</strong></p>
<ul>
<li>如果热 Key 对应的 Value 很大（<strong>大 Value + 热 Key &#x3D; 灾难</strong>），超高的 QPS 会瞬间占满该服务器的出口带宽，导致连正常的 SSH 连接都变得困难，并可能影响同一机器或同一交换机下的其他服务。</li>
</ul>
<p><strong>3. 连接数耗尽，资源不足</strong></p>
<ul>
<li>大量的客户端连接涌向同一个 Redis 节点，可能会耗尽该节点的最大连接数（<code>maxclients</code>），导致新的合法连接无法建立，出现 <code>Cannot assign requested address</code> 或 <code>Connection timeout</code> 等错误。</li>
</ul>
<p><strong>4. 缓存击穿，压垮数据库</strong></p>
<ul>
<li>如果这个热 Key 恰好<strong>过期失效</strong>，或者缓存服务因压力过大而崩溃，海量的请求会直接穿透缓存，全部打到后端数据库（如 MySQL）上。</li>
<li>数据库根本无法承受如此高的并发查询，很快就会被压垮，从而导致整个系统雪崩。</li>
</ul>
<blockquote>
<p>三、如何发现热 Key？</p>
</blockquote>
<p><strong>1. 预估判断</strong></p>
<ul>
<li>根据业务经验，提前预测哪些可能会成为热 Key，如秒杀商品、热门话题等。</li>
</ul>
<p><strong>2. 客户端收集</strong></p>
<ul>
<li>在业务代码中嵌入统计逻辑，记录每个 Key 的访问频次，然后上报给监控系统。</li>
</ul>
<p><strong>3. Redis 自带命令</strong></p>
<ul>
<li><strong>redis-cli –hotkeys</strong>：Redis 4.0 以上版本提供的命令，可以快速找出热点 Key。（注意：在生产环境使用可能对性能有影响）</li>
<li><strong>monitor</strong>：可以实时打印出 Redis 处理的所有命令，然后通过脚本分析。<strong>严禁在生产环境长时间使用</strong>，会严重拖慢 Redis 性能。</li>
</ul>
<p><strong>4. 网络抓包分析</strong></p>
<ul>
<li>通过一些网络抓包工具（如 TCPdump）分析流量，推断出热点 Key。</li>
</ul>
<p><strong>5. 借助第三方监控工具</strong></p>
<ul>
<li>使用 <code>Redis-Faina</code>（Instagram 开源）等工具来分析 <code>monitor</code> 命令的输出。</li>
<li>使用云服务商（如阿里云、腾讯云）提供的商业版 Redis 监控功能，它们通常自带热 Key 分析功能。</li>
</ul>
<blockquote>
<p>四、解决方案</p>
</blockquote>
<p>解决热 Key 问题的核心思路是：<strong>分散压力，化点为面</strong>。</p>
<p><strong>1. 二级本地缓存（最有效、最常用的方案）</strong></p>
<ul>
<li><strong>方法</strong>：在访问 Redis 之前，增加一层本地缓存（如 Guava Cache, Caffeine, Ehcache）。</li>
<li><strong>实施</strong>：<ol>
<li>当热 Key 请求到来时，首先检查本地缓存。</li>
<li>如果本地缓存有，直接返回。</li>
<li>如果本地缓存没有，才去查询 Redis，并将结果写入本地缓存（设置一个较短的过期时间，比如几秒钟）。</li>
</ol>
</li>
<li><strong>优点</strong>：绝大部分请求根本不会走到 Redis，压力被分散到各个应用服务器上。</li>
<li><strong>缺点</strong>：需要解决本地缓存的一致性问题和内存管理问题。</li>
</ul>
<p><strong>2. 备份 Key（读写分离）</strong></p>
<ul>
<li><strong>方法</strong>：将一个热 Key 复制出多个副本（<code>key1</code>, <code>key2</code>, <code>key3</code>, …），分散到不同的 Redis 节点上（如果是集群模式）或存储在同一个实例中。</li>
<li><strong>实施</strong>：<ol>
<li><strong>写操作</strong>：同时更新所有的备份 Key。</li>
<li><strong>读操作</strong>：在客户端采用随机策略，随机访问某一个备份 Key，将流量打散。</li>
</ol>
</li>
<li><strong>优点</strong>：实现起来相对简单。</li>
<li><strong>缺点</strong>：数据一致性难以保证，更新逻辑更复杂。</li>
</ul>
<p><strong>3. 使用 Redis 集群并增加副本（Read Replicas）</strong></p>
<ul>
<li><strong>方法</strong>：为 Redis 集群中的主节点增加多个从节点（副本），让读请求可以分流到从节点上。</li>
<li><strong>实施</strong>：通过读写分离，让主节点只处理写请求，而让多个从节点来分担大量的读请求。</li>
<li><strong>优点</strong>：Redis 原生支持，架构清晰。</li>
<li><strong>缺点</strong>：<strong>无法解决单一热 Key 的问题</strong>，因为同一个 Key 的数据只存在于一个主从组中，读请求仍然会压垮该主从组中的节点。主要用于提升整体读能力。</li>
</ul>
<p><strong>4. 业务逻辑优化</strong></p>
<ul>
<li><strong>方法</strong>：避免在 Value 中存储过大的数据。或者将热点数据“化整为零”。</li>
<li><strong>示例</strong>：对于一个热门帖子的评论列表，不要只用一个 <code>List</code> 来存，可以按页拆分，如 <code>comment:postid:1</code>, <code>comment:postid:2</code>。</li>
</ul>
<p><strong>你可以这样回答（总分总结构）：</strong></p>
<blockquote>
<p>“热 Key 问题是指某个 Key 在瞬间被大量请求访问，比如每秒几十万次，导致这个 Key 所在的 Redis 节点成为瓶颈，CPU、带宽、连接数全部被打满，进而引发服务雪崩。</p>
<p>它的<strong>核心危害</strong>有四个：1. 打满单节点性能；2. 占满网络带宽；3. 耗尽连接数；4. 导致缓存击穿，压垮数据库。</p>
<p>解决热 Key 的核心思路是<strong>分散压力</strong>，主要有两个方案：</p>
<ol>
<li><strong>二级本地缓存</strong>：这是最有效的方法。在应用层用 Guava Cache 或 Caffeine 做一层本地缓存，让绝大部分请求根本到不了 Redis，从而把集中式的压力分散到所有应用服务器上。</li>
<li><strong>备份 Key</strong>：将热 Key 复制多份，比如 <code>key1</code>, <code>key2</code>，客户端随机访问其中一个，把对单个 Key 的访问压力分摊到多个 Key 上。</li>
</ol>
<p>当然，首先要能<strong>及时发现</strong>热 Key，可以通过业务预估、<code>redis-cli --hotkeys</code> 命令或第三方监控工具来实现。在实际项目中，我们通常首选<strong>二级本地缓存</strong>的方案来预防和解决热 Key 问题。”</p>
</blockquote>
<p>这样的回答，既点明了问题本质和危害，又给出了具体、可落的解决方案，层次清晰，能让面试官非常满意。</p>
<h2 id="9-缓存预热"><a href="#9-缓存预热" class="headerlink" title="9.缓存预热"></a>9.缓存预热</h2><p><strong>缓存预热</strong>就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ </p>
<p>常见的缓存预热方式有两种：</p>
<ol>
<li>使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>
<li>使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>
</ol>
<hr>
<h1 id="5-底层结构"><a href="#5-底层结构" class="headerlink" title="5.底层结构"></a>5.底层结构</h1><p>String——动态字符串SDS</p>
<p>List——双向链表</p>
<p>Set——哈希表</p>
<p>主要是ZSet的底层数据结构实现——跳表</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png" class="lazyload" data-srcset="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="底层结构"></p>
<h2 id="1-SDS"><a href="#1-SDS" class="headerlink" title="1.SDS"></a>1.SDS</h2><p>Redis 是用 C 语言实现的，但其String类型是采用了一个叫做简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串。</p>
<blockquote>
<p>为什么不用C语言中的字符串呢？</p>
</blockquote>
<ol>
<li><p>获取字符串长度的<strong>时间复杂度</strong>为 O（N）；</p>
</li>
<li><p>字符串的结尾是以 “\0” 字符标识，这就要求字符串里面不能包含有 “\0” 字符， 因此<strong>不能保存二进制数据</strong>； </p>
</li>
<li><p>字符串操作函数不高效且不安全， 比如有<strong>缓冲区溢出</strong>的风险，有可能会造成程序运行终止； </p>
<p>例：strcat 函数是可以将两个字符串拼接在一起。 <strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>， 所以 strcat 函数假定程序员在执行这个函数时，已经为拼接的字符串分配了足够多的内存，而如果没有，就会发生溢出</p>
</li>
</ol>
<blockquote>
<p>SDS结构</p>
</blockquote>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/516738c4058cdf9109e40a7812ef4239.png" class="lazyload" data-srcset="https://cdn.xiaolincoding.com//mysql/other/516738c4058cdf9109e40a7812ef4239.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SDS结构"></p>
<p>引入了len，alloc，flags解决了C语言字符串的问题</p>
<ol>
<li><strong>len，记录了字符串长度</strong>。 获取字符串长度 时间复杂度<strong>只需要 O（1）</strong>。 </li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。 这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小，也<strong>不会出现前面所说的缓冲区溢出的问题</strong>。 </li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。 <strong>能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。 </li>
<li><strong>buf[]，字节数组，用来保存实际数据</strong>。不仅可以保存字符串，也<strong>可以保存二进制数据</strong>。</li>
</ol>
<h2 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2.双向链表"></a>2.双向链表</h2><p><img src="https://cdn.xiaolincoding.com//mysql/other/cadf797496816eb343a19c2451437f1e.png" class="lazyload" data-srcset="https://cdn.xiaolincoding.com//mysql/other/cadf797496816eb343a19c2451437f1e.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="双向链表"></p>
<p>优点：</p>
<ol>
<li>listNode 链表节点的结构里带有 prev 和 next 指针， <strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，</strong></li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail， 所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**； </li>
<li>list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；</li>
</ol>
<p>缺点：</p>
<ol>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。 能很好利用 CPU 缓存的数据结构就是数组， 因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li>
</ol>
<h2 id="3-压缩列表ZipList"><a href="#3-压缩列表ZipList" class="headerlink" title="3.压缩列表ZipList"></a>3.压缩列表ZipList</h2><p>压缩列表是 Redis 为了<strong>节约内存</strong>而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>， 有点类似于数组。 </p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" class="lazyload" data-srcset="https://cdn.xiaolincoding.com//mysql/other/ab0b44f557f8b5bc7acb3a53d43ebfcb.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="压缩列表"></p>
<p>压缩列表在表头有三个字段： </p>
<ul>
<li><strong>zlbytes</strong>，记录整个压缩列表占用的内存字节数；</li>
<li><strong>zltail</strong>，记录压缩列表「尾部」节点距离起始地址有多少字节， 也就是列表尾的偏移量； </li>
<li><strong>zllen</strong>，记录压缩列表包含的节点数量；</li>
<li><strong>zlend</strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>压缩列表解决了双向列表内存碎片的问题，因为双向链表每个节点存放在内存中不连续的位置。另外，ziplist 为了在细节上节省内存，对于值的存储采用了 <strong>变长编码方式</strong>， 大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。 </p>
<p>压缩列表的缺点是会发生连锁更新的问题，因此<strong>连锁更新一旦发生，</strong> <strong>就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。 </p>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>， 只要节点数量足够小，即使发生连锁更新，也是能接受的。 </p>
<h2 id="4-哈希表"><a href="#4-哈希表" class="headerlink" title="4.哈希表"></a>4.哈希表</h2><p><strong><code>dictionary</code>   字典    <code>dict</code></strong></p>
<p>哈希表结构，哈希冲突，链式哈希这些都不说了，比较熟悉了，下面是不太熟悉的</p>
<blockquote>
<p>1.rehash（扩容）</p>
</blockquote>
<p>也就是<strong>哈希表的扩容</strong>（不过注意<strong>区别：</strong>处理哈希冲突有个<strong>再哈希法</strong>，那个意思是再用另一个哈希函数计算要插入的位置）</p>
<p>在实际使用哈希表时，Redis 定义一个 dict 结构体，这个结构体里定义了<strong>两个哈希表（ht[2]）</strong>。之所以定义了 2 个哈希表，是因为进行 rehash 的时候，需要用上 2 个哈希表了。</p>
<p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表2」 并没有被分配空间。随着数据逐步增多，触发了rehash 操作，这个过程分为三步:</p>
<ul>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大一倍（两倍的意思）；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ul>
<p>一图说明</p>
<p><strong>PS：这里个人觉得很像JVM中的复制算法，两个空间交替使用完之后，然后交换名字继续用</strong></p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/cabce0ce7e320bc9d9b5bde947b6811b.png" class="lazyload" data-srcset="https://cdn.xiaolincoding.com//mysql/other/cabce0ce7e320bc9d9b5bde947b6811b.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="rehash"></p>
<ol>
<li>原哈希表的数据迁移到新的哈希表（长度是原来的2倍）</li>
<li>迁移完成后，释放原哈希表的空间，并让新哈希表指向原哈希表的地址</li>
</ol>
<p>这样有个问题，就是如果哈希表数据过多，在迁移的时候，<strong>因为会涉及大量的数据拷贝，此时可能会对 Redis 造成阻塞，无法服务其他请求</strong>。 所以引出了<strong>渐进式hash</strong></p>
<blockquote>
<p>2.渐进式hash——<strong>解决rehash第二步数据迁移可能会阻塞Redis的痛点</strong></p>
</blockquote>
<p>渐进式hash把一次性大量数据迁移工作的开销，分摊到了多次处理请求的过程中， 避免了一次性 rehash 的<strong>耗时</strong>操作。 </p>
<p>为了支持渐进式重哈希，Redis 的 <strong>dict</strong> 结构包含两个哈希表：</p>
<ul>
<li>**ht[0]**：当前正在使用的哈希表。</li>
<li>**ht[1]**：用于重哈希的目标哈希表（初始为空）。</li>
</ul>
<p>渐进式 rehash 步骤如下： </p>
<p>哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找， 如果没找到，就会继续到哈希表 2 里面进行找到。 在渐进式 rehash 进行期间，新增一个 key-value 时， 会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作， 这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成， 最终「哈希表 1 」就会变成空表。  </p>
<blockquote>
<p>3.rehash触发条件</p>
</blockquote>
<p>和负载因子有关。负载因子 &#x3D; 哈希表已经保存的节点数&#x2F;哈希表大小</p>
<ul>
<li>*<em>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF <em>写的时候，就会进行 rehash 操作。</em></em> </li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，</strong> <strong>不管有没有有在执行 RDB 快照或 AOF 重写，</strong> <strong>都会强制进行 rehash 操作。</strong></li>
</ul>
<h2 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.整数集合"></a>5.整数集合</h2><p>intset 是一个由整数组成的 <strong>有序集合</strong>，从而便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。 它在内存分配上与 ziplist 有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。 </p>
<p>对于<strong>小集合使用 intset</strong> 来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候， <strong>dict 所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）</strong>。所以，当存储大量的小集合而且集合元素都是数字的时候，用 intset 能节省下一笔可观的内存空间。 </p>
<p>实际上，从时间复杂度上比较， intset 的平均情况是没有 dict 性能高的。以查找为例，intset 是 OO(lgn) 的，而 dict 可以认为是 O(1) 的。但是，由于使用 intset 的时候集合元素个数比较少，所以这个影响不大。 </p>
<h2 id="6-跳表"><a href="#6-跳表" class="headerlink" title="6.跳表"></a>6.跳表</h2><p>链表在查找元素的时候，因为需要逐一查找，所以查询效率非常低，时间复杂度是O(N) ，于是就出现了跳表。<strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong>， 这样的好处是能快读定位数据。 </p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2ae0ed790c7e7403f215acb2bd82e884.png" class="lazyload" data-srcset="https://cdn.xiaolincoding.com//mysql/other/2ae0ed790c7e7403f215acb2bd82e884.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="跳表结构"></p>
<h2 id="7-四种rehash对比"><a href="#7-四种rehash对比" class="headerlink" title="7.四种rehash对比"></a>7.四种rehash对比</h2><p><strong>Rehash（重哈希）</strong>是哈希表在扩容或收缩时，重新计算所有元素在新容量下的位置并迁移数据的过程。核心目的是：</p>
<ol>
<li>维持合理的负载因子(load factor)</li>
<li>减少哈希冲突</li>
<li>优化查询效率</li>
</ol>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">触发条件</th>
<th align="left">执行方式</th>
<th align="left">代表实现</th>
<th align="left">优缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>一次性Rehash</strong></td>
<td align="left">容量达到阈值</td>
<td align="left">全部元素立即迁移</td>
<td align="left">Java HashMap</td>
<td align="left">简单但可能造成明显卡顿</td>
</tr>
<tr>
<td align="left"><strong>渐进式Rehash</strong></td>
<td align="left">容量达到阈值</td>
<td align="left">分多次逐步迁移</td>
<td align="left">Redis哈希表</td>
<td align="left">平滑但实现复杂</td>
</tr>
<tr>
<td align="left"><strong>一致性哈希Rehash</strong></td>
<td align="left">节点增减</td>
<td align="left">只迁移受影响数据</td>
<td align="left">Redis Cluster</td>
<td align="left">迁移量小但需要虚拟节点</td>
</tr>
<tr>
<td align="left"><strong>动态Rehash</strong></td>
<td align="left">自动监测性能</td>
<td align="left">按需触发</td>
<td align="left">Go map</td>
<td align="left">自适应但预测算法复杂</td>
</tr>
</tbody></table>
<h1 id="6-Redis线程模型"><a href="#6-Redis线程模型" class="headerlink" title="6.Redis线程模型"></a>6.Redis线程模型</h1><p>阅读以下文字，对于Redis线程模型相关的常见问题基本就有了一个答案</p>
<ol>
<li><blockquote>
<p>核心前提：操作在内存中完成 + 高效的数据结构</p>
</blockquote>
</li>
</ol>
<ul>
<li><strong>内存中完成：</strong> 这是最关键的一点。与磁盘（即使是SSD）相比，内存的读写速度要快几个数量级。这意味着数据的读写操作本身耗时极短，CPU 执行这些操作的速度非常快，大部分请求的处理时间都花在了网络传输和协议解析上，而不是 CPU 计算上。</li>
<li><strong>高效的数据结构：</strong> Redis 不是简单地将数据扔进内存，而是为不同的数据类型精心设计了最优的数据结构。例如：<ul>
<li>String 使用简单动态字符串（SDS）。</li>
<li>Hash 和 Set 在元素较少时使用压缩列表（ziplist）或整数集合（intset），元素多时转为哈希表或字典。</li>
<li>Sorted Set 使用了跳跃表（skiplist）和哈希表的组合。<br>这些数据结构的设计目标就是<strong>在保证功能的前提下，最大化操作速度并最小化内存占用</strong>。这使得单个操作的 CPU 计算成本非常低。</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> 这两点共同决定了，对于单个客户端请求，CPU 需要做的工作量很小，处理速度极快。</p>
<ol start="2">
<li><blockquote>
<p>瓶颈分析：内存 vs. 网络 vs. CPU</p>
</blockquote>
</li>
</ol>
<ul>
<li><strong>内存是瓶颈：</strong> 因为所有数据都存放在内存中，所以你能存储的数据量上限受限于机器的物理内存大小。内存的价格和扩展成本比磁盘高，这是 Redis 作为内存数据库的天然限制。</li>
<li><strong>网络带宽是瓶颈：</strong> Redis 的处理速度极快，通常每秒能处理数十万甚至上百万次请求。在如此高的吞吐量下，千兆网卡（125 MB&#x2F;s）的带宽很容易成为瓶颈。尤其是在处理大体积的 value（如几个MB的字符串）时，网络 I&#x2F;O 的时间远远超过 CPU 处理命令的时间。</li>
<li><strong>CPU 不是瓶颈：</strong> 正因为单个命令的 CPU 处理成本极低，在绝大多数应用场景下（例如简单的 <code>GET</code>、<code>SET</code>、<code>LPUSH</code> 等），Redis 的服务能力在达到 CPU 饱和之前，早就被内存容量或网络带宽限制住了。提升 CPU 性能（例如增加核心数）并不能让你存储更多数据或增加网络带宽，因此对提升性能没有直接帮助。</li>
</ul>
<blockquote>
<ol start="3">
<li>“自然采用单线程”的深层逻辑</li>
</ol>
</blockquote>
<p>既然 CPU 不是瓶颈，那么引入多线程反而会带来复杂性和开销，单线程则拥有巨大的优势：</p>
<p><strong>1. 避免上下文切换和竞争锁的开销</strong><br>这是最核心的原因。多线程模型虽然能利用多核，但线程间的切换（Context Switching）会消耗大量的 CPU 时间。同时，为了线程安全，必须使用锁（Lock）或其它同步机制来保护共享数据（如内存中的键值对）。加锁、解锁、等待锁释放都会带来额外开销，甚至可能导致线程阻塞，反而降低了性能。单线程模型完美地规避了所有这些开销和复杂性，实现了最高的效率。</p>
<p><strong>2. 避免同步问题，实现原子性</strong><br>单线程意味着<strong>所有操作都是串行执行的</strong>。每一个操作在执行时都是独占整个 CPU 时间的，中间不会有其他操作介入。这天然地保证了所有操作的<strong>原子性</strong>（Atomicity），无需任何额外的并发控制。开发者在编写 Lua 脚本或使用 Redis 命令时，无需担心数据竞争（Race Condition）的问题，极大地简化了系统设计和应用开发。</p>
<p>需要强调的是，我们所说的 Redis “单线程”指的是 <strong>其核心的网络 I&#x2F;O 和键值对读写操作是由一个线程完成的</strong>。</p>
<ul>
<li><strong>Redis 6.0 之后的多线程：</strong> 现代版本的 Redis 确实引入了多线程，但这<strong>并不是为了并行执行命令</strong>（命令执行仍然是单线程的），而是为了<strong>处理网络 I&#x2F;O</strong>。即，使用多个 I&#x2F;O 线程来并行地读取请求和写回响应，而真正执行命令的仍然是那个单线程。这样做的目的是为了将耗时的网络 I&#x2F;O 操作从主线程中卸载，从而进一步提升整体性能，尤其是在高并发场景下。这恰恰印证了原话中的判断——瓶颈在于网络。</li>
<li><strong>后台线程：</strong> 此外，Redis 还有一些后台线程用于执行一些慢速的、可能阻塞的操作，如异步删除（<code>UNLINK</code>）、持久化（AOF fsync）等，以避免这些操作阻塞主线程。</li>
</ul>
<h2 id="1-单线程模型"><a href="#1-单线程模型" class="headerlink" title="1.单线程模型"></a>1.单线程模型</h2><ul>
<li><p>如果仅仅聊Redis的核心业务部分(命令处理)，答案是单线程</p>
</li>
<li><p>如果是聊整个Redis，那么答案就是多线程</p>
</li>
</ul>
<p> Redis 在处理网络请求是使用单线程模型，并通过 IO 多路复用来提高并发。 但是在其他模块，比如：持久化，会使用多个线程。 </p>
<p>Redis 内部使用文件事件处理器 <code>file event handler</code>，<strong>这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型</strong>。它采用 IO 多路复用机制同时监听多个 <code>socket</code> ，将产生事件的 <code>socket</code> 压入内存队列中，事件分派器根据 <code>socket</code> 上的事件类型来选择对应的事件处理器进行处理。 </p>
<p>文件事件处理器如下：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/database/redis/redis-event-handler.png" class="lazyload" data-srcset="https://oss.javaguide.cn/github/javaguide/database/redis/redis-event-handler.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="文件事件处理器"></p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h2 id="2-为什么Redis单线程模型也能效率这么高？"><a href="#2-为什么Redis单线程模型也能效率这么高？" class="headerlink" title="2.为什么Redis单线程模型也能效率这么高？"></a>2.为什么Redis单线程模型也能效率这么高？</h2><p>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，<strong>它的性能瓶颈是网络延迟以及内存限制</strong>而不是执行速度，因此多线程并不会带来巨大的性能提升。</p>
<ol>
<li>纯内存操作</li>
<li>避免多线程频繁的上下文切换开销，以及并发加锁开销</li>
<li>IO多路复用模型，允许同时监听多个socket</li>
</ol>
<h2 id="3-既然Redis单线程也那么快，为什么后面又采用了多线程？"><a href="#3-既然Redis单线程也那么快，为什么后面又采用了多线程？" class="headerlink" title="3.既然Redis单线程也那么快，为什么后面又采用了多线程？"></a>3.既然Redis单线程也那么快，为什么后面又采用了多线程？</h2><p><strong>核心答案：Redis 的核心处理逻辑仍然是单线程的，它引入多线程主要是为了卸载那些最耗时的【网络 I&#x2F;O】和【持久化】任务，从而释放主线程（单线程）的压力，让其更专注、更高效地处理核心命令。</strong> </p>
<h3 id="1-Redis-单线程为什么快？（复习）"><a href="#1-Redis-单线程为什么快？（复习）" class="headerlink" title="1.Redis 单线程为什么快？（复习）"></a>1.Redis 单线程为什么快？（复习）</h3><p>在理解“为什么变”之前，先要理解“为什么以前行”。Redis 单线程模型之所以高效，源于以下几点：</p>
<ol>
<li><strong>纯内存操作</strong>：数据存储在内存中，读写速度极快。</li>
<li><strong>单线程避免上下文切换</strong>：单线程避免了多线程频繁切换 CPU 上下文带来的巨大开销。</li>
<li><strong>避免锁竞争</strong>：单线程自然避免了多线程环境下复杂的同步机制（如锁）带来的性能和复杂度问题。</li>
<li><strong>非阻塞 I&#x2F;O 多路复用</strong>：使用 epoll 等机制，用单个线程管理成千上万的网络连接，高效地处理连接、读写事件。</li>
</ol>
<h3 id="2-为什么单线程模型会遇到瓶颈？"><a href="#2-为什么单线程模型会遇到瓶颈？" class="headerlink" title="2.为什么单线程模型会遇到瓶颈？"></a>2.为什么单线程模型会遇到瓶颈？</h3><p>随着网络硬件性能的提升和业务数据量的爆炸式增长，单线程模型的瓶颈不再在 CPU，而转移到了以下两个方面：</p>
<p><strong>1. 网络 I&#x2F;O（最大的瓶颈）</strong></p>
<ul>
<li>在千兆&#x2F;万兆网卡已成为标配的今天，网络数据的读写速度极高。</li>
<li><strong>所有网络数据的读写、解析都由主线程完成</strong>，这变成了一个沉重的负担。当客户端数量极多、流量极大时，主线程会花费大量时间在 I&#x2F;O 上，而不是处理命令，导致延迟增加，QPS 无法进一步提升。</li>
</ul>
<p><strong>2. 持久化（次要瓶颈）</strong></p>
<ul>
<li><strong>fork 操作</strong>：在执行 <code>BGSAVE</code> 或 <code>BGREWRITEAOF</code> 进行持久化时，需要调用 <code>fork</code> 创建子进程。<code>fork</code> 操作本身在数据量大时是<strong>阻塞的</strong>，而且会消耗大量 CPU 资源，尤其是云服务环境下。</li>
<li><strong>AOF 刷盘</strong>：如果使用 <code>appendfsync always</code> 策略，每个命令都要刷盘，主线程会等待这个磁盘 I&#x2F;O 完成。</li>
</ul>
<h3 id="3-Redis-的“多线程”具体指什么？"><a href="#3-Redis-的“多线程”具体指什么？" class="headerlink" title="3.Redis 的“多线程”具体指什么？"></a>3.Redis 的“多线程”具体指什么？</h3><p>Redis 引入的多线程是<strong>非常克制和有选择性的</strong>，并非像 MySQL 那样用多线程来处理所有客户端连接。</p>
<p><strong>1. 多线程网络 I&#x2F;O（Redis 6.0 引入）</strong></p>
<ul>
<li><strong>做了什么</strong>：将网络数据的<strong>读写</strong>（Socket 的读和写）这部分最耗时的操作，交给一组<strong>独立的 I&#x2F;O 线程</strong>去并行处理。</li>
<li><strong>没做什么</strong>：<strong>命令的解析（Parsing）、执行（Execute）、返回结果的组装</strong>，仍然由主线程<strong>串行</strong>完成。这完美地保留了单线程无锁竞争的优势。</li>
<li><strong>工作流程</strong>：<ol>
<li>主线程负责通过 I&#x2F;O 多路复用接收连接，并将 Socket 连接分配给 I&#x2F;O 线程。</li>
<li>I&#x2F;O 线程并行地从这些 Socket 中读取请求数据，并将其解析为命令，<strong>然后放入一个队列中等待主线程处理</strong>。</li>
<li><strong>主线程串行地从队列中取出命令并执行</strong>。</li>
<li>执行完成后，主线程将结果放入另一个回复队列。</li>
<li>I&#x2F;O 线程并行地从回复队列中取出结果，写回给对应的客户端 Socket。</li>
</ol>
</li>
<li><strong>默认关闭</strong>：该功能默认是关闭的，需要配置 <code>io-threads</code>（设置线程数）和 <code>io-threads-do-reads yes</code> 来开启。</li>
</ul>
<p><strong>2. 后台线程处理慢操作（Redis 4.0 引入）</strong></p>
<ul>
<li><strong>目的</strong>：将一些原本由主线程执行的<strong>慢操作</strong>异步化，交给后台线程处理，避免阻塞主线程。</li>
<li><strong>典型任务</strong>：<ul>
<li><strong>异步删除</strong>：<code>UNLINK</code>、<code>FLUSHDB ASYNC</code>、<code>FLUSHALL ASYNC</code> 命令。删除一个大 Key 可能在毫秒级，用 <code>DEL</code> 会阻塞主线程，而用 <code>UNLINK</code> 会交给后台线程慢慢删。</li>
<li><strong>异步持久化</strong>：虽然 <code>fork</code> 本身无法异步，但一些相关的清理工作可以交由线程处理。</li>
</ul>
</li>
</ul>
<h3 id="4-面试回答技巧"><a href="#4-面试回答技巧" class="headerlink" title="4.面试回答技巧"></a>4.面试回答技巧</h3><p><strong>面试官：既然Redis单线程也那么快，为什么后面又采用了多线程？</strong></p>
<p><strong>你可以这样回答：</strong></p>
<blockquote>
<p>“Redis 单线程快是建立在纯内存操作和避免上下文切换的基础上的。但随着硬件发展，尤其是万兆网卡的普及，<strong>网络 I&#x2F;O 的处理逐渐成为了最大的瓶颈</strong>。主线程花费大量时间在读写网络数据上，限制了性能的进一步提升。</p>
<p>所以 Redis 引入多线程并非为了改变其核心的单线程命令处理模型，而是一种<strong>非常精巧的优化</strong>，主要体现在两方面：</p>
<ol>
<li><strong>多线程网络 I&#x2F;O（Redis 6.0）</strong>：将最耗时的网络数据<strong>读写操作</strong>从主线程中卸载，交给一组 I&#x2F;O 线程去<strong>并行处理</strong>。而<strong>命令的解析和执行</strong>这个核心逻辑，依然由主线程<strong>串行</strong>完成。这样既利用了多核来突破网络 I&#x2F;O 瓶颈，又保留了单线程无锁设计的全部优势。</li>
<li><strong>后台线程（Redis 4.0）</strong>：将一些慢操作，如大 Key 的<strong>异步删除（UNLINK）</strong>，交给后台线程处理，避免阻塞主线程。</li>
</ol>
<p>总之，Redis 的‘多线程’是<strong>辅助性的</strong>，它的目标不是变成一个多线程数据库，而是为了解放那个核心的单线程，让它跑得更快。这体现了 Redis 作者一种非常务实和平衡的设计哲学。”</p>
</blockquote>
<p>这样的回答，既说明了历史原因，又解释了新技术方案解决的具体问题，还体现了你对技术细节的把握，绝对是面试官想要的满分答案。</p>
<h1 id="7-高可用"><a href="#7-高可用" class="headerlink" title="7.高可用"></a>7.高可用</h1><h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1.主从复制"></a>1.主从复制</h2><p>为了应对并发能力问题，可以搭建主从集群，实现读写分离，Redis大多都是读多写少的场景</p>
<p>多台服务器要保存同一份数据，这些服务器之间的数据如何保持一致性呢？数据的读写操作是否每台服务器都可以处理？ </p>
<p>Redis 提供了<strong>主从复制模式</strong>，来避免上述的问题。 </p>
<p>主从复制的核心过程可以分为<strong>建立连接</strong>、<strong>数据同步</strong>和<strong>命令传播</strong>三个阶段。 </p>
<p>如何确定主从关系？比如想让服务器B变成服务器A的从服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>



<p><strong>建立连接阶段</strong>：</p>
<p>从服务器就会给主服务器发送 <code>psync</code> 命令，表示要进行数据同步。 </p>
<p>psync 命令包含两个参数，分别是<strong>主服务器的 runID</strong> 和<strong>复制进度 offset</strong>。 </p>
<p>在介绍第一次同步的过程之前，需要先介绍两个参数</p>
<p>从服务器就会给主服务器发送 <code>sync</code> 命令，表示要进行数据同步。 sync 命令包含两个参数 ，可以<strong>判断从服务器是否第一次来同步数据</strong></p>
<ol>
<li><p>Replicationld：简称<code>replid</code>，每个 <strong>Redis 服务器</strong>在启动时都会自动生产一个随机的 <strong>ID 来唯一标识自己</strong>。 从服务器会继承主服务器的<code>replid</code></p>
</li>
<li><p>offset：偏移量，表示复制的进度，随着记录在repl_baklog中的数据增多而逐渐增大。主节点用offset记录自己<strong>写</strong>的位置，从节点用offset记录自己<strong>读</strong>的位置。slave完成同步时也会记录当前同步的offset。</p>
<p>如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p>
</li>
</ol>
<p><strong>全量同步阶段</strong>：</p>
<ol>
<li>slave节点发送sync请求，表示要进行数据同步</li>
<li>master将执行 bgsave 命令（异步，不会阻塞主线程）生成RDB，发送RDB到slave。</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将生成RDB期间、发送RBD期间以及「从服务器」加载 RDB 文件期间的命令记录在<code>replication_buffer</code>，当slave加载完RDB后，slave会回复一个确认消息给主服务器。 然后主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器， 主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，</li>
</ol>
<p>至此，主从服务器的第一次同步的工作就完成了。 </p>
<p><strong>命令传播阶段：</strong></p>
<p>主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。 而且这个连接是<strong>长连接</strong>的，目的是避免频繁的 TCP 连接和断开带来的性能开销。 </p>
<ul>
<li>主节点每执行一个<strong>写命令</strong>，都会<strong>异步地</strong>将这个命令发送给所有与其连接的从节点。</li>
<li>从节点接收到命令后，会<strong>执行与主节点相同的命令</strong>，从而保证数据最终一致性。</li>
</ul>
<p>上面的这个过程被称为<strong>基于长连接的命令传播</strong>， </p>
<p><strong>增量同步阶段</strong>：</p>
<p>主从连接短暂中断后重连 ，采用增量同步</p>
<ul>
<li>从节点重连后，会带上自己的 <code>runID</code>（服务器随机生成的ID）和当前的 <code>offset</code>（复制偏移量）发送 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令。</li>
<li>主节点判断 <code>runID</code> 是否与自己一致，并检查 <code>offset</code> 是否还在积压缓冲区中。</li>
<li>如果条件满足，主节点会回复 <code>+CONTINUE</code>，表示进行部分同步。</li>
<li>主节点将积压缓冲区中从 <code>offset</code> 之后的所有写命令发送给从节点。</li>
<li>从节点执行这些命令，即可追上主节点的状态。</li>
</ul>
<p><strong>主服务器怎么知道要将哪些增量数据发送给从服务器呢？</strong> 依赖以下两个东西</p>
<ul>
<li><strong>repl_backlog_buffer</strong>，是一个「<strong>环形</strong>」缓冲区， 用于主从服务器断连后，从中找到差异的数据； </li>
<li><strong>replication offset</strong>，标记上面那个缓冲区的同步进度， 主从服务器都有各自的偏移量</li>
</ul>
<p><strong>这个缓冲区是什么时候写入的呢？</strong></p>
<p>是在命令传播阶段写入的，在主服务器进行命令传播时，不仅会将写命令发送给从服务器， 还会将写命令写入到 repl_backlog_buffer 缓冲区里， 因此 这个缓冲区里会保存着最近传播的写命令。 </p>
<p><strong>注意，这个缓冲区是环形的，也就是存在覆盖的风险！</strong></p>
<p>写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步。</p>
<p>因此，<strong>为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该设置repl_backlog_buffer 缓冲区尽可能的大一些</strong>， 减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用增量同步的方式。 </p>
<blockquote>
<p>主从复制的作用</p>
</blockquote>
<p>①、<strong>数据冗余：</strong> 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</p>
<p>②、<strong>故障恢复：</strong> 如果主节点挂掉了，可以将一个从节点提升为主节点，从而实现故障的快速恢复。</p>
<p>通常会使用 Sentinel 哨兵来实现自动故障转移，当主节点挂掉时，Sentinel 会自动将一个从节点升级为主节点，保证系统的可用性。 假如是从节点挂掉了，主节点不受影响，但应该尽快修复并重启挂掉的从节点，使其重新加入集群并从主节点同步数据。 </p>
<p>③、<strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务 <strong>，分担服务器负载。尤其是在读多写少</strong>的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</p>
<p>④、<strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的 <strong>基础</strong>。</p>
<p><strong>重要特性与细节</strong></p>
<ol>
<li><strong>异步复制</strong>：主节点向从节点发送数据是<strong>异步</strong>的。这意味着：<ul>
<li><strong>高性能</strong>：主节点不会等待从节点的确认，它处理客户端请求的速度非常快。</li>
<li><strong>弱一致性</strong>：主从数据之间存在<strong>短暂延迟</strong>。从节点的数据会稍落后于主节点（最终一致）。</li>
<li><strong>潜在数据丢失风险</strong>：如果主节点在写命令发送给从节点之前宕机，且未开启持久化，那么这个写命令可能会丢失。</li>
</ul>
</li>
<li><strong>复制偏移量与积压缓冲区</strong><ul>
<li>**复制偏移量 (Replication Offset)**：主从节点都会维护一个偏移量（offset）。主节点每次传播一个字节的数据，偏移量就会增加。从节点每次收到数据，也会增加自己的偏移量。通过对比偏移量，可以判断主从数据是否一致。</li>
<li><strong>复制积压缓冲区 (Replication Backlog)<strong>：主节点内部维护的一个</strong>固定长度的、先进先出（FIFO）的队列</strong>。它默认大小为 1MB，用于存放最近传播的写命令。这是实现部分重同步的基础。</li>
</ul>
</li>
<li><strong>服务器运行 ID (Run ID)</strong><ul>
<li>每个 Redis 服务器，无论主从，都会在启动时自动生成一个唯一的 40 位随机十六进制字符串作为 <code>runID</code>。</li>
<li>从节点会保存主节点的 <code>runID</code>。断线重连时，通过对比 <code>runID</code> 来判断连接的是不是原来的主节点。如果不是，就需要进行全量同步。</li>
</ul>
</li>
</ol>
<p><strong>注意两个缓冲区的区别</strong></p>
<p><code>replication buffer</code> 和 <code>repl backlog buffer</code>  </p>
<p><strong>你可以这样回答：</strong></p>
<blockquote>
<p>“这两个 Buffer 在 Redis 主从复制中扮演着完全不同的角色：</p>
<ol>
<li><strong>Replication Buffer</strong>：<ul>
<li>它是<strong>每个从节点独享</strong>的一个<strong>客户端输出缓冲区</strong>。</li>
<li>它的核心作用是在<strong>全量同步</strong>的 <strong>BGSAVE 期间</strong>，<strong>临时存放</strong>主节点收到的新写命令。等从节点加载完 RDB 文件后，主节点再把这个 Buffer 里的命令发过去，保证数据一致性。</li>
<li>如果它溢出了（从节点太慢），主节点会断开对应从节点的连接。</li>
</ul>
</li>
<li><strong>Repl Backlog Buffer</strong>：<ul>
<li>它是主节点上<strong>全局共享</strong>的一个<strong>固定大小的环形缓冲区</strong>。</li>
<li>它的核心作用是在<strong>正常的命令传播阶段</strong>，<strong>持续记录</strong>最近传播的所有写命令，为<strong>部分重同步（也就是增量复制）</strong>提供数据源。当从节点网络闪断重连后，可以直接从这里获取错过的命令，避免全量同步。</li>
<li>如果它溢出了（写命令太多且从节点断开太久），旧数据会被覆盖，导致部分重同步失败，从而退化为全量同步。</li>
</ul>
</li>
</ol>
<p><strong>简单总结</strong>：<code>Replication Buffer</code> 是<strong>同步期</strong>的<strong>临时补给</strong>，而 <code>Repl Backlog Buffer</code> 是<strong>传播期</strong>的<strong>持久化日志</strong>，用于断线重连后的快速恢复。”</p>
</blockquote>
<h2 id="2-哨兵（Sentinel）机制"><a href="#2-哨兵（Sentinel）机制" class="headerlink" title="2.哨兵（Sentinel）机制"></a>2.哨兵（Sentinel）机制</h2><h3 id="1-为什么需要哨兵机制？"><a href="#1-为什么需要哨兵机制？" class="headerlink" title="1.为什么需要哨兵机制？"></a>1.为什么需要哨兵机制？</h3><p><strong>它主要解决了主从复制模式下的核心痛点：故障自动转移（Failover）</strong>。</p>
<p>在主从模式中，如果主节点（Master）宕机，需要<strong>手动</strong>进行以下操作：</p>
<ol>
<li>选择一个从节点（Replica）晋升为新的主节点。</li>
<li>让其他从节点改为复制新的主节点。</li>
<li>通知客户端应用程序切换连接至新的主节点。</li>
</ol>
<p>这个过程繁琐、缓慢且容易出错，无法实现高可用。<strong>Sentinel 的核心目标就是将这个过程自动化</strong>。</p>
<h3 id="2-哨兵的四大功能"><a href="#2-哨兵的四大功能" class="headerlink" title="2.哨兵的四大功能"></a>2.哨兵的四大功能</h3><ol>
<li><strong>监控（Monitoring）</strong>：持续检查主节点和从节点是否处于正常工作状态。</li>
<li><strong>通知（Notification）</strong>：当被监控的 Redis 实例出现问题时，可以通过 API 或其他系统发送通知。</li>
<li><strong>自动故障转移（Automatic Failover）</strong>：当主节点故障时，Sentinel 会自动将一个从节点提升为新的主节点，并让其他从节点复制新的主节点。</li>
<li><strong>配置提供者（Configuration Provider）</strong>：客户端应用首先连接到 Sentinel，询问当前哪个是主节点。故障转移后，Sentinel 会提供新的主节点地址，充当了<strong>服务发现</strong>的中心。</li>
</ol>
<h3 id="3-监控——如何判断主节点真的鼓掌了？"><a href="#3-监控——如何判断主节点真的鼓掌了？" class="headerlink" title="3.监控——如何判断主节点真的鼓掌了？"></a>3.监控——如何判断主节点真的鼓掌了？</h3><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令</p>
<ul>
<li><strong>主观下线</strong>：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li>
<li><strong>客观下线</strong>：为了防止误判，单个 Sentinel 发现主节点主观下线后，它会询问集群中的其他 Sentinel，看它们是否也认为该主节点不可用。当达到一定数量（<strong>quorum</strong>，法定人数，在配置文件中设置）的 Sentinel 都报告主节点主观下线时，此时才判定主节点<strong>客观下线</strong>。</li>
</ul>
<p>quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2 </p>
<h3 id="4-自动故障转移——由哪个哨兵进行主从故障转移"><a href="#4-自动故障转移——由哪个哨兵进行主从故障转移" class="headerlink" title="4.自动故障转移——由哪个哨兵进行主从故障转移"></a>4.自动故障转移——由哪个哨兵进行主从故障转移</h3><p><strong>领导者选举</strong></p>
<p><strong>一旦主节点被判定为客观下线</strong>（<strong>触发Leader选举</strong>），多个 Sentinel 实例需要<strong>选举出一个领导者（Leader）</strong>，由这个领导者来执行故障转移操作。</p>
<p><strong>为什么需要选一个领导者？</strong> 这是为了确保故障转移操作只由一个哨兵来执行，避免多个哨兵同时去操作，导致脑裂或者重复提升从节点等问题。 </p>
<ol>
<li><p><strong>任何哨兵都可以发起投票</strong>：任何一个确认主节点为客观下线的哨兵，都可以向其他哨兵发送命令，请求对方选举自己为领导者。<strong>所以，每个哨兵在理论上都是潜在的候选者。</strong></p>
</li>
<li><p><strong>投票规则</strong>：当一个哨兵收到投票请求时，它会遵循一套严格的规则来决定是否同意：</p>
<ul>
<li><strong>先到先得</strong>：每个哨兵在<strong>一个纪元</strong>内，只会投出<strong>一张票</strong>（先投给谁，后就无法再投给别人）。纪元是一个不断递增的计数器，每次选举都会在一个新的纪元中进行，确保选举的唯一性。</li>
<li><strong>无法自投</strong>：哨兵不能投给自己。</li>
<li><strong>优先投票给优先级高的</strong>：如果没有投过票，它会优先投票给第一个向它发送投票请求的哨兵。</li>
</ul>
</li>
<li><p><strong>成为领导者的条件</strong>：一个哨兵要想成为领导者，必须满足两个条件：</p>
<ul>
<li><strong>获得多数票</strong>：它必须获得超过半数的哨兵节点的同意（注意：这个“半数”是哨兵节点的半数，而不是 <code>quorum</code> 的值）。例如，如果有 5 个哨兵，那么至少需要 3 张票。</li>
<li><strong>获得的票数还必须大于或等于配置文件中配置的 quorum 值</strong>。</li>
</ul>
<p>公式：<code>票数 &gt;= max(quorum, num-sentinels/2 + 1)</code><br>这确保了当选的领导者具有足够的权威性。</p>
</li>
<li><p><strong>选举结果</strong>：</p>
<ul>
<li>如果某个哨兵获得了足够的票数，它就成为了领导者，并开始执行故障转移流程（选一个从节点提升为主节点、修改配置、通知客户端等）。</li>
<li><strong>如果在规定时间内没有哨兵获得足够的票数，选举会失败。等待一段时间（随机延迟）后，会开启新一轮纪元（epoch）的选举</strong>，直到选出一个领导者为止。这个随机延迟有助于避免多个哨兵同时发起投票导致票数分散。</li>
</ul>
</li>
</ol>
<h3 id="5-开始故障转移"><a href="#5-开始故障转移" class="headerlink" title="5.开始故障转移"></a>5.开始故障转移</h3><p><strong>a) 筛选新的主节点</strong> Sentinel Leader 会根据以下规则，从剩余的从节点中筛选出最合适的新主节点： </p>
<ol>
<li><strong>排除不健康的</strong>：断开连接的、最近通信超时的、主观下线的。</li>
<li><strong>排除优先级低的</strong>：比较 <code>slave-priority</code>（或 <code>replica-priority</code>）配置值，<strong>优先级数字越小，优先级越高</strong>。</li>
<li><strong>选择复制偏移量最大的</strong>：优先级相同，则选择复制偏移量（<code>replication offset</code>）最大的从节点（即拥有最完整数据的节点）。</li>
<li><strong>选择 Run ID 最小的</strong>：如果以上都相同，则选择 Run ID 字典序最小的从节点（一个随机策略）。</li>
</ol>
<p><strong>b) 提升新的主节点</strong> </p>
<ol>
<li>向选中的从节点发送 <code>SLAVEOF NO ONE</code> 命令，使其停止复制，晋升为独立的主节点。</li>
<li>每秒发送 <code>INFO</code> 命令检查其角色（<code>role</code>）是否已成功切换为 <code>master</code>。</li>
</ol>
<p><strong>c) 切换并重新配置其他从节点</strong> </p>
<ol>
<li><p>向其他所有从节点发送 <code>SLAVEOF &lt;new_master_ip&gt; &lt;new_master_port&gt;</code> 命令，让它们转而复制新的主节点。</p>
</li>
<li><p>同时，Sentinel 会记住这些旧的从节点配置，<strong>当旧主节点重新上线时，会让它也成为新主节点的从节点</strong>。</p>
</li>
</ol>
<p><strong>d) 通知客户端（Service Discovery）</strong></p>
<p>故障转移完成后，Sentinel 必须通知客户端主节点发生了变化。这是通过 <strong>发布&#x2F;订阅（Pub&#x2F;Sub）</strong> 机制实现的。</p>
<ul>
<li>Sentinel 会向名为 <code>__sentinel__:hello</code> 的频道发布消息，内容包括主节点的配置变化。</li>
<li>客户端需要与 Sentinel 集群保持一个<strong>长期命令连接</strong>，并订阅这个频道。当收到主节点切换的消息时，客户端就能动态地重新连接到新的主节点。</li>
</ul>
<p><strong>更常见的做法是</strong>：客户端使用 <strong>Sentinel 客户端连接池</strong>（如 Jedis、Lettuce 都支持）。客户端首先连接到一个或多个 Sentinel，通过发送 <code>SENTINEL get-master-addr-by-name &lt;master-name&gt;</code> 命令来查询当前主节点的地址。故障转移后，客户端再次查询就能拿到新地址。</p>
<h3 id="5-面试回答技巧"><a href="#5-面试回答技巧" class="headerlink" title="5.面试回答技巧"></a>5.面试回答技巧</h3><p><strong>面试官：详细说一下Redis的哨兵机制。</strong></p>
<p><strong>你可以这样回答（总分总结构）：</strong></p>
<blockquote>
<p>“Redis哨兵（Sentinel）是为解决主从模式无法自动故障转移而设计的高可用方案。它是一个分布式系统，主要提供监控、通知、自动故障转移和服务发现四大功能。</p>
<p>它的核心工作流程可以分为四步：</p>
<ol>
<li><strong>监控与判断下线</strong>：每个Sentinel通过PING命令监控所有节点。当认为主节点<strong>主观下线（SDOWN）</strong> 后，会咨询其他Sentinel，若达成<strong>法定人数（quorum）</strong> 则判定为<strong>客观下线（ODOWN）</strong>，这是触发故障转移的前提。</li>
<li><strong>领导者选举</strong>：多个Sentinel会基于Raft算法选举出一个Leader，由它来执行故障转移，避免混乱。</li>
<li><strong>故障转移</strong>：Leader会根据优先级、复制偏移量等规则，从从节点中选出最合适的作为<strong>新主节点</strong>，并让其他从节点复制它。</li>
<li><strong>通知客户端</strong>：故障转移后，Sentinel通过发布订阅机制或充当配置中心，通知客户端新的主节点地址，完成服务发现。</li>
</ol>
<p>在生产环境中，我们通常需要部署<strong>至少3个Sentinel实例</strong>，并且将它们分散在不同的机器上，以保证其自身的可靠性。”</p>
</blockquote>
<p>这样的回答，既逻辑清晰，又抓住了核心流程和关键细节（主观&#x2F;客观下线、Raft选举），能充分展现你的理解深度。</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ol>
<li>脑裂Sentinel 可以防止脑裂吗？（在小林”主从复制是怎么实现的“那里最后有提到脑裂，可结合gpt看看）</li>
</ol>
<h2 id="3-分片集群（Cluster-）"><a href="#3-分片集群（Cluster-）" class="headerlink" title="3.分片集群（Cluster ）"></a>3.分片<strong>集群</strong>（<strong>Cluster</strong> ）</h2><h3 id="1-为什么需要分片集群？"><a href="#1-为什么需要分片集群？" class="headerlink" title="1.为什么需要分片集群？"></a>1.为什么需要分片集群？</h3><p>主从，和哨兵，都是为了提升Redis的读性能，但所有节点仍然是存储全量数据，加再多从节点，也无法突破单机节点内存瓶颈。且写操作仍然集中在主节点，概括的说，如下：</p>
<ol>
<li><strong>海量数据存储</strong>：单机 Redis 的内存容量有限（如 16GB, 32GB），无法存储数百 GB 或 TB 级别的数据。</li>
<li><strong>高并发写操作</strong>：Redis 是单线程模型，单个主节点的写能力有上限。虽然主从复制和哨兵提供了<strong>高可用</strong>和<strong>读扩展</strong>，但<strong>写操作</strong>仍然集中在单个主节点上，无法扩展。</li>
</ol>
<p><strong>分片集群通过“分而治之”的思想，将数据拆分成多个分片（Shard），每个分片由一个主节点和多个从节点组成（负责该分片的高可用），从而同时实现了：</strong></p>
<ul>
<li><strong>数据的分布式存储</strong>（解决容量问题）</li>
<li><strong>写操作的负载均衡</strong>（解决并发问题）</li>
<li><strong>高可用性</strong>（每个分片内部是主从结构）</li>
</ul>
<h3 id="2-哈希槽"><a href="#2-哈希槽" class="headerlink" title="2.哈希槽"></a>2.哈希槽</h3><p>现在的架构是这样的</p>
<p>客户端发送命令——经过CRC16计算哈希槽——由负责该哈希槽的Redis节点处理请求	（每个Redis节点是一个主从集群）</p>
<ul>
<li><strong>哈希槽的数量</strong>：一个 Redis 集群固定有 <strong>16384</strong> (2^14) 个哈希槽。你可以把它想象成一个有 16384 个插槽的巨型数组。</li>
<li><strong>数据分片规则</strong>：<ol>
<li>对每个写入的 Key，使用 <strong>CRC16</strong> 算法计算出一个哈希值。</li>
<li>将这个哈希值对 <strong>16384</strong> 取模，得到一个介于 0 到 16383 之间的数字，这个数字就是该 Key 所属的哈希槽编号。</li>
<li>集群中的每个主节点（Master）负责处理其中<strong>一部分哈希槽</strong>。</li>
</ol>
</li>
</ul>
<p><strong>示例</strong>：<br>一个三主节点的集群，哈希槽分配可能如下：</p>
<ul>
<li>节点 A：包含 0 到 5500 号哈希槽。</li>
<li>节点 B：包含 5501 到 11000 号哈希槽。</li>
<li>节点 C：包含 11001 到 16383 号哈希槽。</li>
</ul>
<p>当你执行 <code>SET user:1000 &quot;John&quot;</code> 时：</p>
<ol>
<li>计算 <code>CRC16(&quot;user:1000&quot;) % 16384</code>，假设得到 7000。</li>
<li>哈希槽 7000 属于节点 B。</li>
<li>那么这个 Key 的数据就会被存储到节点 B 上。</li>
</ol>
<p><strong>用这个哈希槽的好处</strong>就是，可以动态扩充Redis节点，然后重新分配哈希槽即可。否则如果计算哈希槽时，是对Redis节点个数n取余，那如果增加节点，n会变化，所有的节点都要进行数据迁移</p>
<h3 id="3-Redis实例上没有数据？—Moved重定向-ASK重定向"><a href="#3-Redis实例上没有数据？—Moved重定向-ASK重定向" class="headerlink" title="3.Redis实例上没有数据？—Moved重定向&#x2F;ASK重定向"></a>3.Redis实例上没有数据？—Moved重定向&#x2F;ASK重定向</h3><p><strong>Moved重定向：</strong></p>
<p>客户端给一个Redis实例发送数据读写操作时，如果计算出来的槽不是在该节点上， 这时候它会返回MOVED重定向错误，MOVED重定向错误中， 会将哈希槽所在的新实例的IP和port端口带回去。 </p>
<p><strong>ASK重定向：</strong></p>
<p>Ask重定向一般发生于集群伸缩的时候。当客户端向<strong>源节点</strong>请求一个键，而该键<strong>已经被迁移</strong>到了<strong>目标节点</strong>时，源节点无法处理这个请求，但它会返回一个 <strong>ASK</strong> 错误给客户端。 </p>
<table>
<thead>
<tr>
<th>特性</th>
<th>MOVED 重定向</th>
<th>ASK 重定向</th>
</tr>
</thead>
<tbody><tr>
<td><strong>含义</strong></td>
<td><strong>永久性重定向</strong>。槽的负责权已经<strong>完全转移</strong>。</td>
<td><strong>临时性重定向</strong>。槽的负责权正在<strong>转移过程中</strong>。</td>
</tr>
<tr>
<td><strong>发生场景</strong></td>
<td>集群稳定状态，客户端请求了错误的节点。</td>
<td>集群数据迁移（Resharding）过程中。</td>
</tr>
<tr>
<td><strong>客户端行为</strong></td>
<td>客户端<strong>更新本地槽位映射缓存</strong>，之后所有对该槽的请求都直接发往新节点。</td>
<td>客户端<strong>不更新本地槽位映射缓存</strong>，只是<strong>临时地</strong>对本次请求发往新节点。</td>
</tr>
</tbody></table>
<h3 id="4-TODO各个节点之间是如何通信的——Gossip协议"><a href="#4-TODO各个节点之间是如何通信的——Gossip协议" class="headerlink" title="4.TODO各个节点之间是如何通信的——Gossip协议"></a>4.TODO各个节点之间是如何通信的——Gossip协议</h3><h3 id="5-TODO故障转移"><a href="#5-TODO故障转移" class="headerlink" title="5.TODO故障转移"></a>5.TODO故障转移</h3><h3 id="6-TODO为什么Redis分片集群的哈希槽长度是16384-2-14"><a href="#6-TODO为什么Redis分片集群的哈希槽长度是16384-2-14" class="headerlink" title="6.TODO为什么Redis分片集群的哈希槽长度是16384   2^14"></a>6.TODO为什么Redis分片集群的哈希槽长度是16384   2^14</h3><h1 id="7-场景"><a href="#7-场景" class="headerlink" title="7.场景"></a>7.场景</h1><h2 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1.分布式锁"></a>1.分布式锁</h2><p>一个最基本的分布式锁需要满足：</p>
<ul>
<li><strong>互斥</strong>：任意一个时刻，锁只能被一个线程持有。</li>
<li><strong>高可用</strong>：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。</li>
<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>
</ul>
<p>除了上面这三个基本条件之外，一个好的分布式锁还需要满足下面这些条件：</p>
<ul>
<li><strong>高性能</strong>：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。</li>
<li><strong>非阻塞</strong>：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li>
</ul>
<blockquote>
<p>使用Redis命令设计的基础分布式锁</p>
</blockquote>
<p><code>setnx ex</code>，这样可以设置一个简单的分布式锁，<code>setnnx</code>是如果key不存在，则创建key，否则失败；而<code>ex</code>则给这个key设置了过期时间，避免锁无法释放。</p>
<p>而且Redis的命令都是原子性的，这样就保持了获得锁和设置过期时间是一起操作的</p>
<p>对于自己设计的分布式锁，如果要保证<strong>判断该锁是否为自己的</strong>和<strong>释放锁</strong>这两个操作为原子操作，就需要用<strong>Lua脚本</strong>。释放锁的时候判断是否与获得锁的线程id一样</p>
<blockquote>
<p>Redisson</p>
</blockquote>
<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。 </p>
<p>而redisson不仅实现了上述功能，还更为强大，有以下功能：</p>
<ol>
<li><strong>自动续期</strong></li>
<li>可重入</li>
<li>读写锁</li>
<li>公平锁</li>
</ol>
<p>下面介绍redisson原理</p>
<p>加锁</p>
<p>key是锁的名称，value是个map，<strong>map的key是线程id，value是锁的重入次数，然后设置锁过期时间</strong></p>
<p><img src="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redisson-renew-expiration.png" class="lazyload" data-srcset="https://oss.javaguide.cn/github/javaguide/distributed-system/distributed-lock/distributed-lock-redisson-renew-expiration.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="加锁成功"></p>
<ul>
<li>如果加锁成功，锁的重入次数加一，这就实现了重入锁的功能；<ul>
<li>加锁成功后，就会执行一个看门狗的机制。看门狗机制是为了防止业务还没执行完，但锁到期了的问题。看门狗就是一个<strong>定时任务</strong>，只要当前线程任务没有挂掉，且没有主动释放锁，就会隔一段时间给锁续期。默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。</li>
</ul>
</li>
<li>如果失败，返回锁的过期时间<ul>
<li>加锁失败后，会进入一个循环中，此线程会被semaphore阻塞，当之前的线程释放锁后，会通过semaphore来唤醒此线程，然后获得锁后跳出此循环</li>
</ul>
</li>
<li>释放锁时，如果该锁的线程id不是自己的，就无权释放；如果是，就将重入次数减一，如果减后的重入次数还是＞0，就不能释放，更新锁到期时间，否则就释放锁，然后发送锁释放消息，唤醒被阻塞的线程</li>
</ul>
<p>无论加锁成功或失败，都会有一个future结果器来接收加锁结果</p>
<h2 id="2-如何设计一个秒杀场景"><a href="#2-如何设计一个秒杀场景" class="headerlink" title="2.如何设计一个秒杀场景"></a>2.如何设计一个秒杀场景</h2><h1 id="8-面试题"><a href="#8-面试题" class="headerlink" title="8.面试题"></a>8.面试题</h1><ul>
<li><input disabled="" type="checkbox"> redis是什么? Redis架构是怎么样的？怎么设计redis？ RDB是什么，AOF是什么？RDB和AOF的区别是什么？ Redis有什么作用？ Redis为什么要单线程？ Redis redis的持久化机制是怎么样的？ Redis支持String，List，Set，Zset Redis支持哪些数据类型？ Redis是单线程吗？ Redis缓存过期策略 Redis缓存淘汰策略 缓存过期策略和缓存淘汰策略的区别是什么？ LRU是什么？ Redis-cli是什么？ Redis通信协议是怎么样的？ Redis的协议格式是怎么样的？ 为什么Redis不用HTTP？ RedisJson是什么？ RediSearch是什么？ RediTImeSeries是什么？ RedisGraph是什么？ Redis的高可用，高性能怎么做？ Redis是什么？ 主从模式是什么？主从模式的具体实现细节？ 主从同步中有数据写入怎么办？ 经典主从模式有什么问题？ 哨兵是什么？ 哨兵模式是什么？ 哨兵集群是什么？ Redis怎么提升高可用？ 什么是主观下线和客观下线 Redis内存不足的解决方案 Redis集群模式架构解析 Redis数据切分方法详解 Redis哈希槽工作原理 Redis集群高可扩展性实现 Redis单机崩溃服务不可用问题 Redis集群节点扩容步骤 Redis哈希槽迁移过程 Redis读写重定向机制 Redis CLUSTER SLOTS命令详解 Redis数据迁移期间访问策略 Redis集群主从故障切换流程 Redis集群客户端连接实践 Redis集群与主从复制区别 Redis避免全量数据迁移方法 Redis扩容后数据分布逻辑 Redis哈希槽16384个原因 Redis高可用高扩展实现 Redis突破单机内存限制方案 Redis集群模式数据分片原理 Redis键值分片计算公式 Redis节点增减数据迁移风险 Redis哈希槽固定长度优势 Redis集群节点间通信机制 Redis重定向错误处理方法 Redis集群客户端库推荐 Redis迁移状态判断技巧 Redis集群主节点选举过程 Redis集群读写请求流程示例 Redis集群三主节点配置案例 Redis哈希槽范围分配规则 Redis集群扩容数据迁移量 Redis客户端slot缓存机制 Redis集群节点宕机处理 Redis集群数据持久化策略 Redis集群性能优化技巧 Redis集群监控关键指标 Redis集群常见问题排查 Redis集群槽位重新分配 Redis集群数据一致性保障 Redis集群慢查询优化 Redis集群大Key处理方案 Redis集群热Key解决方案 Redis集群管道技术使用 Redis集群事务支持情况 Redis集群Lua脚本限制 Redis集群如何分片数据 Redis集群节点职责划分 Redis集群数据重定向原理 Redis集群为什么需要16384个槽 Redis集群扩容时数据迁移量 Redis集群客户端如何感知节点变化 Redis集群主节点故障处理流程 Redis集群从节点如何提升为主节点 Redis集群如何保证高可用性 Redis集群数据分布策略详解 Redis键值对如何映射到哈希槽 Redis集群跨槽操作支持情况 Redis数据切分是什么 Redis重定向机制是什么 Redis CLUSTER SLOTS命令是什么 Redis集群节点扩容是什么 Redis哈希槽迁移是什么 Redis主从故障切换是什么 Redis集群高可扩展性是什么 Redis集群高可用性是什么 Redis键值分片计算是什么 Redis集群节点通信是什么 Redis集群跨槽操作是什么 Redis槽位重新分配是什么 Redis客户端Slot缓存是什么</li>
</ul>

  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2025-09-07T15:47:32+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：2025年9月7日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Redis/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>Redis</p></a></div>
  <span hidden itemprop="keywords">Redis</span>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2024/10/28/%E5%85%AB%E8%82%A1/JVM/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>JVM</p>
          <p class='content'>这里是有关JVM的八股




1.引言1.JVM的特性对字节码文件中的指令，实时解释成机器码，让机器执行
最重要的特性还是跨平台，以下是其它特性
①、垃圾回收：JVM 可以自动管理内存，通过垃...</p>
        </a>
      
      
        <a class='next' href='/2024/10/28/%E5%85%AB%E8%82%A1/Mysql/'>
          <p class='title'>Mysql<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>这里是数据库MYSQL的一些八股知识




MySQL默认端口3306
1.基础知识1.MyISAM与InnoDB区别存储引擎（Storage Engine）是用来定义数据表如何存储、读取、管...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2024/10/28/%E5%85%AB%E8%82%A1/Redis/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80"><span class="toc-text">1.基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-text">1.Redis为什么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.Redis有哪些数据类型？常用的使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-String%E8%BF%98%E6%98%AFHash%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%9B%B4%E5%A5%BD%E5%91%A2%EF%BC%9F"><span class="toc-text">3.String还是Hash存储对象更好呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.Redis可以用来做什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">2.持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RDB"><span class="toc-text">1.RDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RDB%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%88Copy-on-Write%EF%BC%89"><span class="toc-text">2.RDB写时复制（Copy-on-Write）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AOF"><span class="toc-text">3.AOF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-AOF%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="toc-text">4.AOF三种写回策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-text">5.AOF重写机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-text">6.如何选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3.Redis内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">1.过期键的删除策略有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%B2%97%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text">2.内存淘汰粗略有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E7%AF%87"><span class="toc-text">4.缓存篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88"><span class="toc-text">1.缓存一致性方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">2.缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-text">3.布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E5%AE%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">一、核心概念：它是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F%EF%BC%89"><span class="toc-text">二、工作原理（它是如何工作的？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0-Add"><span class="toc-text">1. 添加元素 (Add)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0-Check"><span class="toc-text">2. 查询元素 (Check)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">4.缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">5.缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A4%A7Key%E9%97%AE%E9%A2%98"><span class="toc-text">6.大Key问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Redis%E5%A4%A7key%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">7.Redis大key如何影响持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%83%ADKey"><span class="toc-text">8.热Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-text">9.缓存预热</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">5.底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SDS"><span class="toc-text">1.SDS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-text">2.双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8ZipList"><span class="toc-text">3.压缩列表ZipList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">4.哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-text">5.整数集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B7%B3%E8%A1%A8"><span class="toc-text">6.跳表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%9B%9B%E7%A7%8Drehash%E5%AF%B9%E6%AF%94"><span class="toc-text">7.四种rehash对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">6.Redis线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">1.单线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B9%9F%E8%83%BD%E6%95%88%E7%8E%87%E8%BF%99%E4%B9%88%E9%AB%98%EF%BC%9F"><span class="toc-text">2.为什么Redis单线程模型也能效率这么高？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A2%E7%84%B6Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B9%9F%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8E%E9%9D%A2%E5%8F%88%E9%87%87%E7%94%A8%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">3.既然Redis单线程也那么快，为什么后面又采用了多线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F%EF%BC%88%E5%A4%8D%E4%B9%A0%EF%BC%89"><span class="toc-text">1.Redis 单线程为什么快？（复习）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BC%9A%E9%81%87%E5%88%B0%E7%93%B6%E9%A2%88%EF%BC%9F"><span class="toc-text">2.为什么单线程模型会遇到瓶颈？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Redis-%E7%9A%84%E2%80%9C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%9D%E5%85%B7%E4%BD%93%E6%8C%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.Redis 的“多线程”具体指什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%8A%80%E5%B7%A7"><span class="toc-text">4.面试回答技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-text">7.高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">1.主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%93%A8%E5%85%B5%EF%BC%88Sentinel%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-text">2.哨兵（Sentinel）机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">1.为什么需要哨兵机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%A8%E5%85%B5%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%8A%9F%E8%83%BD"><span class="toc-text">2.哨兵的四大功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9C%9F%E7%9A%84%E9%BC%93%E6%8E%8C%E4%BA%86%EF%BC%9F"><span class="toc-text">3.监控——如何判断主节点真的鼓掌了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E2%80%94%E2%80%94%E7%94%B1%E5%93%AA%E4%B8%AA%E5%93%A8%E5%85%B5%E8%BF%9B%E8%A1%8C%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-text">4.自动故障转移——由哪个哨兵进行主从故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BC%80%E5%A7%8B%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-text">5.开始故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%8A%80%E5%B7%A7"><span class="toc-text">5.面试回答技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TODO"><span class="toc-text">TODO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%EF%BC%88Cluster-%EF%BC%89"><span class="toc-text">3.分片集群（Cluster ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="toc-text">1.为什么需要分片集群？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%93%88%E5%B8%8C%E6%A7%BD"><span class="toc-text">2.哈希槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Redis%E5%AE%9E%E4%BE%8B%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE%EF%BC%9F%E2%80%94Moved%E9%87%8D%E5%AE%9A%E5%90%91-ASK%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">3.Redis实例上没有数据？—Moved重定向&#x2F;ASK重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-TODO%E5%90%84%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%E2%80%94%E2%80%94Gossip%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.TODO各个节点之间是如何通信的——Gossip协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TODO%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-text">5.TODO故障转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-TODO%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E7%9A%84%E5%93%88%E5%B8%8C%E6%A7%BD%E9%95%BF%E5%BA%A6%E6%98%AF16384-2-14"><span class="toc-text">6.TODO为什么Redis分片集群的哈希槽长度是16384   2^14</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%9C%BA%E6%99%AF"><span class="toc-text">7.场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">1.分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF"><span class="toc-text">2.如何设计一个秒杀场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">8.面试题</span></a></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.add("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="none";
      cover_wrapper.style.display="none";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
          
            
          
        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/app.js"></script>



  
  
  
  <div id="rightmenu-wrapper">
    <ul class="list-v rightmenu" id="rightmenu-content">
      <li class='navigation menuNavigation-Content'>
        <a class='nav icon-only fix-cursor-default' onclick='history.back()'><i class='fa fa-arrow-left fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='history.forward()'><i class='fa fa-arrow-right fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' onclick='window.location.reload()'><i class='fa fa-redo fa-fw'></i></a>
        <a class='nav icon-only fix-cursor-default' href='/'><i class='fa fa-home fa-fw'></i></a>
      </li>
      <li class='option menuOption-Content'>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyText'>
          
          <i class='fa fa-copy fa-fw'></i> 复制文本
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyPaste'>
          
          <i class='fa fa-paste fa-fw mR12'></i> 粘贴文本
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copySelect'>
          
          <i class='fa fa-object-ungroup fa-fw mR12'></i> 全选文本
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyCut'>
          
          <i class='fa fa-cut fa-fw mR12'></i> 剪切文本
        </span>
        
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='searchWord'>
          
          <i class='fa fa-search fa-fw'></i> 站内搜索
        </span>
        
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='openTab'>
          
          <i class='fa fa-external-link-square-alt fa-fw mR12'></i> 在新标签页打开
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copySrc'>
          
          <i class='fa fa-image fa-fw mR12'></i> 复制图片地址
        </span>
        <span class='vlts-menu opt fix-cursor-default menu-Option' data-fn-type='copyImg'>
          
          <i class='fa fa-images fa-fw mR12'></i> 复制图片文件
        </span>
      </li>
      
        
      
        
          <hr class="menuLoad-Content">
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://volantis.js.org/faqs/
        
        
        
        
          id="https:volantisjsorgfaqs"
        
      >
        <i class='fa fa-question fa-fw'></i> 常见问题
      </a>
    </li>
  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://volantis.js.org/examples/
        
        
        
        
          id="https:volantisjsorgexamples"
        
      >
        <i class='fa fa-rss fa-fw'></i> 示例博客
      </a>
    </li>
  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://volantis.js.org/contributors/
        
        
        
        
          id="https:volantisjsorgcontributors"
        
      >
        <i class='fa fa-fan fa-spin fa-fw'></i> 加入社区
      </a>
    </li>
  
        
      
        
          <hr class="menuLoad-Content">
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/volantis-docs/
        
        
        
        
          id="https:githubcomvolantis-xvolantis-docs"
        
      >
        <i class='fa fa-code-branch fa-fw'></i> 本站源码
      </a>
    </li>
  
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' href=https://github.com/volantis-x/hexo-theme-volantis/
        
        
        
        
          id="https:githubcomvolantis-xhexo-theme-volantis"
        
      >
        <i class='fa fa-code-branch fa-fw'></i> 主题源码
      </a>
    </li>
  
        
      
        
          <hr class="menuLoad-Content">
        
      
        
          <li class='option menuOption-Content'>
            <span class='vlts-menu opt fix-cursor-default' id='printHtml'>
              <i class='fa fa-print fa-fw '></i> 打印页面
            </span>
          </li>
        
      
        
          <li class='option menuOption-Content'>
            <span class='vlts-menu opt fix-cursor-default toggle-mode-btn' id='menuDarkBtn'>
              <i class='fa fa-moon fa-fw '></i> 暗黑模式
            </span>
          </li>
        
      
        
          <li class='option menuOption-Content'>
            <span class='vlts-menu opt fix-cursor-default' id='readingModel'>
              <i class='fa fa-book-open fa-fw '></i> 阅读模式
            </span>
          </li>
        
      
        
          
    <li class="menuLoad-Content">
      <a class='vlts-menu fix-cursor-default' 
        
        
        
        
      >
         
      </a>
    </li>
  
        
      
    </ul>
  </div>
  <script>volantis.js('https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/rightMenu.js')</script>




  













<div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
    
  <li class='navigation menuNavigation-Content'>


    <a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa-solid fa-arrow-left fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa-solid fa-arrow-right fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa-solid fa-redo fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)"><i class="fa-solid fa-arrow-up fa-fw"></i></a>


  </li>


    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyPaste" data-event="copyPaste" data-group="inputBox">
      <i class="fa-solid fa-paste fa-fw"></i>
      粘贴文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyAll" data-event="copyAll" data-group="inputBox">
      <i class="fa-solid fa-object-ungroup fa-fw"></i>
      全选文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyCut" data-event="copyCut" data-group="inputBox">
      <i class="fa-solid fa-cut fa-fw"></i>
      剪切文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyText" data-event="copyText" data-group="seletctText">
      <i class="fa-solid fa-copy fa-fw"></i>
      复制文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="searchWord" data-event="OpenSearch(__text__)" data-group="seletctText">
      <i class="fa-solid fa-search fa-fw"></i>
      站内搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="bingSearch" data-event="window.open(`https://cn.bing.com/search?q=${__text__}`)" data-group="seletctText">
      <i class="fa-solid fa-search fa-fw"></i>
      必应搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="openTab" data-event="window.open(__link__)" data-group="elementCheck">
      <i class="fa-solid fa-external-link-square-alt fa-fw"></i>
      新标签页打开
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyLink" data-event="copyLink" data-group="elementCheck">
      <i class="fa-solid fa-link fa-fw"></i>
      复制链接地址
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyImg" data-event="copyImg" data-group="elementImage">
      <i class="fa-solid fa-image fa-fw"></i>
      复制图片
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="googleImg" data-event="window.open(`https://www.google.com.hk/searchbyimage?image_url=${__link__}`)" data-group="elementImage">
      <i class="fa-solid fa-images fa-fw"></i>
      谷歌识图
    </span>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="help" target="_blank" rel="noopener" href="https://volantis.js.org/faqs/" data-group="link">
      <i class="fa-solid fa-question fa-fw"></i>
      常见问题
    </a>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="examples" target="_blank" rel="noopener" href="https://volantis.js.org/examples/" data-group="link">
      <i class="fa-solid fa-rss fa-fw"></i>
      示例博客
    </a>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="contributors" target="_blank" rel="noopener" href="https://volantis.js.org/contributors/" data-group="link">
      <i class="fa-solid fa-fan fa-fw"></i>
      加入社区
    </a>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="source_docs" target="_blank" rel="noopener" href="https://github.com/volantis-x/volantis-docs/" data-group="link">
      <i class="fa-solid fa-code-branch fa-fw"></i>
      本站源码
    </a>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="source_theme" target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/" data-group="link">
      <i class="fa-solid fa-code-branch fa-fw"></i>
      主题源码
    </a>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="darkMode" data-event="volantis.dark.toggle()" data-group="darkMode">
      <i class="fa-solid fa-moon fa-fw"></i>
      暗黑模式
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="printMode" data-event="printMode" data-group="articlePage">
      <i class="fa-solid fa-print fa-fw"></i>
      打印页面
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="readMode" data-event="readMode" data-group="articlePage">
      <i class="fa-solid fa-book-open fa-fw"></i>
      阅读模式
    </span>
  </li>


<div id="menuMusic">
  <li class='music name menuOption-Content'>
    <p class='nav music-title fix-cursor-default'></p>
  </li>
  <li class='music ctrl'>
    <a class='nav icon-only backward fix-cursor-default' href="/" onclick="return false;" title="backward">
      <i class='fa-solid fa-step-backward fa-fw'></i>
    </a>
    <a class='nav icon-only toggle fix-cursor-default' href="/" onclick="return false;" title="toggle">
      <i class='fa-solid fa-play fa-fw'></i>
    </a>
    <a class='nav icon-only forward fix-cursor-default' href="/" onclick="return false;" title="forward">
      <i class='fa-solid fa-step-forward fa-fw'></i>
    </a>
  </li>
  <li class='music volume'>
    <div class='nav volume'>
      <div class="aplayer-volume-bar-wrap">
        <div class="aplayer-volume-bar fix-cursor-pointer">
          <div class="aplayer-volume"></div>
          <i class='left fa-solid fa-volume-off fa-fw'></i>
          <i class='right fa-solid fa-volume-up fa-fw'></i>
        </div>
      </div>
    </div>
  </li>
</div>

  </ul>
</div>
<script src="https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/rightMenus.js"></script>
<script>
  const RightMenusFunction = {};
  












  //RightMenusFunction['copyPaste'] = (fun) => {fun()}





  //RightMenusFunction['copyAll'] = (fun) => {fun()}





  //RightMenusFunction['copyCut'] = (fun) => {fun()}





  //RightMenusFunction['copyText'] = (fun) => {fun()}





  RightMenusFunction['searchWord'] = (__text__) => {OpenSearch(__text__)}





  RightMenusFunction['bingSearch'] = (__text__) => {window.open(`https://cn.bing.com/search?q=${__text__}`)}





  RightMenusFunction['openTab'] = (__link__) => {window.open(__link__)}





  //RightMenusFunction['copyLink'] = (fun) => {fun()}





  //RightMenusFunction['copyImg'] = (fun) => {fun()}





  RightMenusFunction['googleImg'] = (__link__) => {window.open(`https://www.google.com.hk/searchbyimage?image_url=${__link__}`)}



















  RightMenusFunction['darkMode'] = () => {volantis.dark.toggle()}





  //RightMenusFunction['printMode'] = (fun) => {fun()}





  //RightMenusFunction['readMode'] = (fun) => {fun()}





</script>



<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->

  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "color-scheme";
const rootElementDarkModeAttributeName = "color-scheme";
const setLS = (k, v) => {
    localStorage.setItem(k, v);
};
const removeLS = (k) => {
    localStorage.removeItem(k);
};
const getLS = (k) => {
    return localStorage.getItem(k);
};
const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};
const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};
const validColorModeKeys = {
  dark: true,
  light: true,
};
const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);
  getCustomDarkMode();
  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};
const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};
/**
 * get target mode
 */
 const getCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  if(currentSetting=="dark"){
    volantis.dark.mode="light";
  }else{
    volantis.dark.mode="dark";
  }
  // console.log(volantis.dark.mode)
};
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};
/**
 * 暗黑模式触发器
 */
volantis.dark.toggle=()=>{
  const mode = toggleCustomDarkMode();
  applyCustomDarkModeSettings(mode);
  // 使用 volantis.dark.push 方法传入volantis.dark.toggle回调函数 参见layout/_partial/scripts/global.ejs
  volantis.dark.method.toggle.start();
}
/**
 * bind event for toggle button
 */

function bindToggleButton() {
  var btn= document.querySelectorAll("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn")
  btn.forEach(function (e) {
    volantis.dom.$(e).on('click',volantis.dark.toggle);
  })
}
applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", ()=>{
  volantis.requestAnimationFrame(bindToggleButton)
});
volantis.pjax.push(bindToggleButton);

const darkModelListeners={
  dark:(mediaQueryList )=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "dark";
    }
    volantis.dark.method.toggle.start();
  },
  light:(mediaQueryList)=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "light";
    }
    volantis.dark.method.toggle.start();
  }
}
window.matchMedia('(prefers-color-scheme: dark)').addListener(darkModelListeners.dark)
window.matchMedia('(prefers-color-scheme: light)').addListener(darkModelListeners.light)
</script>




<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>









      <script>
  volantis.layoutHelper("comments",`<div id="utterances"></div>`)
  volantis.utterances={}
  volantis.utterances.ThemeLight='github-light';
  volantis.utterances.ThemeDark='github-dark';
  volantis.utterances.Theme=volantis.utterances.ThemeLight;
  function pjax_utterances(){
    if(!document.getElementById("utterances"))return;
    
      if(volantis.dark.mode=="dark"){
        volantis.utterances.Theme=volantis.utterances.ThemeDark;
      }else{
        volantis.utterances.Theme=volantis.utterances.ThemeLight;
      }
    
    setTimeout(function() {
      var checkUtterances = setInterval(function () {
        var HEAD = document.getElementById("utterances");
        if (!HEAD) return
        clearInterval(checkUtterances)
        try {
          document.getElementById("utterances").innerHTML="";
        } catch (error) {}
        var script = document.createElement('script');
        script.setAttribute('src','https://utteranc.es/client.js');
        script.setAttribute('repo','Big-Light/Big-Light.github.io');
        let issuenumber = '';
        if (issuenumber) {
          script.setAttribute('issue-number', issuenumber);
        } else {
          script.setAttribute('issue-term', 'pathname');
        }
        script.setAttribute('theme', volantis.utterances.Theme );
        script.setAttribute('label','✨💬✨');
        script.setAttribute('crossorigin', "anonymous");
        HEAD.appendChild(script);
      }, 200)
    });
  }
  pjax_utterances();
  volantis.pjax.push(pjax_utterances);
  volantis.dark.push(pjax_utterances);
</script>

    




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/busuanzi/js/busuanzi.pure.mini.js" data-pjax></script>


<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("https://unpkg.com/hexo-theme-volantis@5.8.0/source/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"light","url":"http://example.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"Light","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/","sameAs":["https://github.com/volantis-x"],"description":"啊咧咧啊咧咧啊咧啊咧咧~"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://example.com/","name":"light"}},{"@type":"ListItem","position":2,"item":{"@id":"http://example.com/categories/八股/","name":"八股"}},{"@type":"ListItem","position":3,"item":{"@id":"http://example.com/2024/10/28/八股/Redis/","name":"Redis"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"light","url":"http://example.com/","keywords":null,"description":"啊咧咧啊咧咧啊咧啊咧咧~","author":{"@type":"Person","name":"Light","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/","description":"啊咧咧啊咧咧啊咧啊咧咧~"},"publisher":{"@type":"Organization","name":"light","url":"http://example.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://example.com?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"Redis","description":"这里是Redis相关的八股","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/Redis/"},"author":{"@type":"Person","name":"Light","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/"},"publisher":{"@type":"Organization","name":"light","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/Redis/","wordCount":13,"datePublished":"2024-10-28T12:14:56.000Z","dateModified":"2025-09-07T07:47:32.637Z","articleSection":"八股","keywords":"Redis","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
