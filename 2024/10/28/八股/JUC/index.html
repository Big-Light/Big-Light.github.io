<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JUC | 知行合一</title><meta name="author" content="Light"><meta name="copyright" content="Light"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、线程基础1、线程和进程的区别？ 进程 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。  线程 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC">
<meta property="og:url" content="http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/JUC/index.html">
<meta property="og:site_name" content="知行合一">
<meta property="og:description" content="1、线程基础1、线程和进程的区别？ 进程 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。 在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。  线程 线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg">
<meta property="article:published_time" content="2024-10-28T12:14:32.000Z">
<meta property="article:modified_time" content="2024-12-16T03:15:13.103Z">
<meta property="article:author" content="Light">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/JUC/index.html"><link rel="preconnect"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css?v=0.1.16" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css?v=5.0.33" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js?v=4.11.1',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-16 11:15:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/icon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-desktop"></i><span> 学习</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/algorithm/"><i class="fa-fw fas fa-coffee"></i><span> 算法</span></a></li><li><a class="site-page child" href="/2024/09/11/%E6%8A%80%E6%9C%AF%E7%B1%BB/Mysql%E5%AD%A6%E4%B9%A0/"><i class="fa-fw fas fa-poo"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/Java8/"><i class="fa-fw fas fa-poo"></i><span> Java八股</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-seedling"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fas fa-pencil"></i><span> 随笔</span></a></li><li><a class="site-page child" href="/cartoon/"><i class="fa-fw fas fa-grin-stars"></i><span> 动漫</span></a></li><li><a class="site-page child" href="/2024/10/10/%E5%BD%B1%E8%A7%86%E7%82%B9%E8%AF%84/"><i class="fa-fw fas fa-grin-stars"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="知行合一"><span class="site-name">知行合一</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-desktop"></i><span> 学习</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/algorithm/"><i class="fa-fw fas fa-coffee"></i><span> 算法</span></a></li><li><a class="site-page child" href="/2024/09/11/%E6%8A%80%E6%9C%AF%E7%B1%BB/Mysql%E5%AD%A6%E4%B9%A0/"><i class="fa-fw fas fa-poo"></i><span> MySQL</span></a></li><li><a class="site-page child" href="/Java8/"><i class="fa-fw fas fa-poo"></i><span> Java八股</span></a></li></ul></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-seedling"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-camera-retro"></i><span> 图片</span></a></li><li><a class="site-page child" href="/notes/"><i class="fa-fw fas fa-pencil"></i><span> 随笔</span></a></li><li><a class="site-page child" href="/cartoon/"><i class="fa-fw fas fa-grin-stars"></i><span> 动漫</span></a></li><li><a class="site-page child" href="/2024/10/10/%E5%BD%B1%E8%A7%86%E7%82%B9%E8%AF%84/"><i class="fa-fw fas fa-grin-stars"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-28T12:14:32.000Z" title="发表于 2024-10-28 20:14:32">2024-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-16T03:15:13.103Z" title="更新于 2024-12-16 11:15:13">2024-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%85%AB%E8%82%A1/">八股</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、线程基础"><a href="#1、线程基础" class="headerlink" title="1、线程基础"></a>1、线程基础</h2><h3 id="1、线程和进程的区别？"><a href="#1、线程和进程的区别？" class="headerlink" title="1、线程和进程的区别？"></a>1、线程和进程的区别？</h3><ol>
<li><p>进程</p>
<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
</li>
<li><p>线程</p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。 与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源， 但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间做切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
</li>
</ol>
<p><strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong> </p>
<h3 id="2、并行与并发有什么区别？"><a href="#2、并行与并发有什么区别？" class="headerlink" title="2、并行与并发有什么区别？"></a>2、并行与并发有什么区别？</h3><ul>
<li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
<li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
</ul>
<h3 id="3、创建线程的方式有哪些？-四种）"><a href="#3、创建线程的方式有哪些？-四种）" class="headerlink" title="3、创建线程的方式有哪些？(四种）"></a>3、创建线程的方式有哪些？(四种）</h3><ul>
<li><p>继承 Thread 类</p>
<ol>
<li>定义一个Thread类的子类，重写run方法；</li>
<li>创建自定义的线程子类对象</li>
<li>调用子类实例的star()方法来启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法正在执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(); 	</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>实现 Runnable 接口</p>
<ol>
<li>定义Runnable接口实现类MyRunnable，并重写run()方法</li>
<li>创建MyRunnable实例myRunnable，以myRunnable作为target创建Thead对象，<strong>该Thread对象才是真正的线程对象</strong></li>
<li>调用线程对象的start()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run()方法执行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>实现 Callable 接口</p>
<ol>
<li>创建实现Callable接口的类myCallable</li>
<li>以myCallable为参数创建FutureTask对象</li>
<li>将FutureTask作为参数创建Thread对象</li>
<li>调用线程对象的start()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; call()方法执行中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;返回结果 &quot;</span> + futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; main()方法执行完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>使用 Executors 工具类创建线程池</p>
<p>Executors提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService接口。</p>
<p>主要有newFixedThreadPool，newCachedThreadPool，newSingleThreadExecutor，newScheduledThreadPool，后续详细介绍这四种线程池</p>
</li>
</ul>
<h3 id="4、runnable-和-callable-有什么区别？"><a href="#4、runnable-和-callable-有什么区别？" class="headerlink" title="4、runnable 和 callable 有什么区别？"></a>4、runnable 和 callable 有什么区别？</h3><ol>
<li>Runnable 接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，需要FutureTask获取结果</li>
<li>Callable接口的call()方法允许抛出异常;而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ol>
<h3 id="5、run-和-start-有什么区别"><a href="#5、run-和-start-有什么区别" class="headerlink" title="5、run()和 start()有什么区别?"></a>5、run()和 start()有什么区别?</h3><ol>
<li>start():用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。</li>
<li>start方法只能被调用一次。run():封装了要被线程执行的代码，可以被调用多次。</li>
</ol>
<h3 id="6、线程包括哪些状态？状态之间是如何变化的？"><a href="#6、线程包括哪些状态？状态之间是如何变化的？" class="headerlink" title="6、线程包括哪些状态？状态之间是如何变化的？"></a>6、线程包括哪些状态？状态之间是如何变化的？</h3><p>状态：新建(NEW)、可运行(RUNNABLE)、阻塞(BLOCKED)、等待(WAITING)、时间等待(TIMED_WALTING)、终止(TERMINATED)</p>
<p>变化：</p>
<ol>
<li>创建线程对象是<strong>新建状态</strong></li>
<li>调用了start()方法转变为<strong>可执行状态线</strong></li>
<li>程获取到了CPU的执行权，执行结束是<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态<ol>
<li>如果没有获取锁(synchronized或lock)进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入<strong>等待状态</strong>，其他线程调用notify()唤醒后可切换为可执行状态</li>
<li>如果线程调用了sleep(50)方法，进入<strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ol>
</li>
</ol>
<h3 id="7、notify（）和notifyAll（）的区别？"><a href="#7、notify（）和notifyAll（）的区别？" class="headerlink" title="7、notify（）和notifyAll（）的区别？"></a>7、notify（）和notifyAll（）的区别？</h3><p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。 </p>
<h3 id="8、Java中sleep和wait方法有什么不同？"><a href="#8、Java中sleep和wait方法有什么不同？" class="headerlink" title="8、Java中sleep和wait方法有什么不同？"></a>8、Java中sleep和wait方法有什么不同？</h3><p> 两者都可以暂停线程的执行 </p>
<p>不同点在于：</p>
<ul>
<li>类的不同：sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。</li>
<li>sleep() 不释放锁；wait() 释放锁。 </li>
<li><code>wait()</code> 方法被调用后，线程不会自动苏醒， 需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。 <code>sleep()</code>方法执行完成后，线程会自动苏醒 ，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。 </li>
<li>用途不同：Wait 通常被用于线程间交互&#x2F;通信，sleep 通常被用于暂停执行。</li>
</ul>
<h3 id="8、如何停止一个正在运行的线程？"><a href="#8、如何停止一个正在运行的线程？" class="headerlink" title="8、如何停止一个正在运行的线程？"></a>8、如何停止一个正在运行的线程？</h3><ol>
<li>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止(不推荐，方法已作废)</li>
<li>使用interrupt方法中断线程<ul>
<li>打断阻塞的线程(sleep，wait，join)的线程，线程会抛出InteruptedException异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ol>
<h3 id="9、线程-进程之间的通信方式"><a href="#9、线程-进程之间的通信方式" class="headerlink" title="9、线程&#x2F;进程之间的通信方式"></a>9、线程&#x2F;进程之间的通信方式</h3><p><strong>线程</strong></p>
<p>线程之间的通信由于共享同一个进程的内存空间，可以通过共享数据或同步机制实现。以下是主要的通信方式： </p>
<ol>
<li><strong>共享变量</strong>：多个线程通过共享变量直接读写数据。比如说 volatile 和 synchronized 关键字。 </li>
<li>**使用 wait() 和 notify()**，例如，生产者-消费者模式中，生产者生产数据，消费者消费数据，通过 <code>wait()</code> 和 <code>notify()</code> 方法可以实现生产和消费的协调。 </li>
<li><strong>ReentrantLock 和条件变量</strong>：*使用 <code>ReentrantLock</code> 提供的 <code>Condition</code> 对象进行线程通信。</li>
</ol>
<p><strong>进程</strong></p>
<p>进程之间由于没有共享内存，通信需要依赖操作系统提供的 IPC（Inter-Process Communication）机制。 </p>
<ol>
<li><strong>管道（Pipe）</strong>：单向通信，适用于父子进程间。</li>
<li><strong>信号（Signal）</strong>：进程之间通过信号传递简单的通知或控制信息。</li>
<li><strong>消息队列</strong>：内核维护的消息队列，支持消息的发送和接收，适合多进程通信。</li>
<li><strong>套接字（Socket）</strong>：通过网络通信协议实现跨主机的通信，也可以用于本地进程通信。</li>
<li>**信号量(Semaphores)**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)<strong>：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。 这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是</strong>最有用的进程间通信方式</strong>。</li>
</ol>
<h3 id="10、导致并发程序出现问题的根本原因是说什么？（Java程序中怎么保证多线程的执行安全）并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？"><a href="#10、导致并发程序出现问题的根本原因是说什么？（Java程序中怎么保证多线程的执行安全）并发编程三要素是什么？在-Java-程序中怎么保证多线程的运行安全？" class="headerlink" title="10、导致并发程序出现问题的根本原因是说什么？（Java程序中怎么保证多线程的执行安全）并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？"></a>10、导致并发程序出现问题的根本原因是说什么？（Java程序中怎么保证多线程的执行安全）并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</h3><ol>
<li><p>原子性：原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。</p>
<p>可见性：一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）</p>
<p>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</p>
<p>出现线程安全问题的原因：</p>
<ul>
<li>线程切换带来的原子性问题</li>
<li>缓存导致的可见性问题</li>
<li>编译优化带来的有序性问题</li>
</ul>
<p>解决办法：</p>
<ul>
<li>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</li>
<li>synchronized、volatile、LOCK，可以解决可见性问题</li>
<li>Happens-Before 规则可以解决有序性问题</li>
</ul>
</li>
</ol>
<h3 id="11、死锁产生的条件是什么？"><a href="#11、死锁产生的条件是什么？" class="headerlink" title="11、死锁产生的条件是什么？"></a>11、死锁产生的条件是什么？</h3><ol>
<li><p>产生死锁的四个必要条件</p>
<ol>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
</li>
<li><p>产生死锁的情况</p>
<p>1.互斥锁顺序问题:如果多个线程按不同的顺序获取锁，并且互相依赖对方释放的锁，就有可能导致死锁。<br>2.资源竞争问题:当多个线程同时竞争有限的资源，例如共享的数据库连接、文件等，在资源分配不当的情况下，可能导致死锁。</p>
</li>
<li><p>如何检测死锁</p>
<p>​	使用jstack命令或者使用 VisuaIVM</p>
</li>
<li><p>解决死锁的办法</p>
<p>解决死锁可采取以下方法:</p>
<ul>
<li><p>避免死锁的发生，通过破坏死锁产生的四个必要条件之一来预防;</p>
<p><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
</li>
<li><p>检测死锁，使用算法检测出是否存在死锁，并采取相应的措施解除死锁;</p>
</li>
<li><p>恢复死锁，即进行资源的强制抢占或进行回滚操作，将进程回退到安全状态以解除死锁。</p>
</li>
</ul>
</li>
</ol>
<h3 id="12、可以直接调用Thread的run方法吗？"><a href="#12、可以直接调用Thread的run方法吗？" class="headerlink" title="12、可以直接调用Thread的run方法吗？"></a>12、可以直接调用Thread的run方法吗？</h3><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</strong></p>
<h3 id="13、同步-异步"><a href="#13、同步-异步" class="headerlink" title="13、同步&#x2F;异步"></a>13、同步&#x2F;异步</h3><ul>
<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong>：调用在发出之后，不用等待返回结果，该调用直接返回。</li>
</ul>
<hr>
<h2 id="2、voliatle"><a href="#2、voliatle" class="headerlink" title="2、voliatle"></a>2、voliatle</h2><ol>
<li><p><strong>保证线程间的可见性</strong></p>
<p>确保一个线程的修改能对其他线程是可见的。当一个共享变量被 volatile 修饰时，它会保证修改的值会被更新到<strong>主存</strong>，当有其他线程需要读取时，它会去内存中读取新值。 </p>
</li>
<li><p><strong>禁止指令重排序</strong></p>
<p>如果我们将变量声明为 <strong>volatile</strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。<br>以下供理解：</p>
<p>简单说就是JVM为了对代码进行优化提高性能会在不影响结果的情况下把代码执行顺序改变，但<strong>多线程就可能会出现结果不对的问题</strong><br>然后volatile原理就是加了一些屏障，使屏障后的代码一定不会比屏障前的代码先执行，从而实现有序性</p>
</li>
</ol>
<h2 id="3、乐观锁和悲观锁"><a href="#3、乐观锁和悲观锁" class="headerlink" title="3、乐观锁和悲观锁"></a>3、乐观锁和悲观锁</h2><ol>
<li><p>悲观锁</p>
<ul>
<li>悲观锁:认为自己在使用数据的时候一定有别的线程来修改数据，在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li>
<li>锁实现:关键字synchronized、接口Lock的实现类</li>
<li>适用场景:写操作较多，先加锁可以保证写操作时数据正确</li>
</ul>
</li>
<li><p>乐观锁</p>
<ul>
<li><p>乐观锁:认为自己使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据</p>
</li>
<li><p>锁实现1:CAS算法，CAS即 Compare And swap，是一种更新的原子操作</p>
<ul>
<li><strong>V</strong>：要更新的变量值(Var)</li>
<li><strong>E</strong>：预期值(Expected)</li>
<li><strong>N</strong>：拟写入的新值(New)</li>
</ul>
<p>当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。 ActomicInteger类的原子自增是通过CAS自选实现。</p>
</li>
<li><p>锁实现 2:版本号控制:数据表中加上版本号字段 version，表示数据被修改的次数。当数据被修改时这个字段值会加1，当更新数据时，同时比较版本号，若当前版本号和更新前获取的版本号一致， 则更新成功，否则失败。 </p>
</li>
<li><p>适用场景:读操作较多，不加锁的特点能够使其读操作的性能大幅提升</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-6、CAS存在的缺点（问题）"><a href="#3-2-6、CAS存在的缺点（问题）" class="headerlink" title="3.2.6、CAS存在的缺点（问题）"></a>3.2.6、CAS存在的缺点（问题）</h3><ol>
<li><p>ABA问题</p>
<p>ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。</p>
</li>
<li><p>循环时间开销大</p>
<p>自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。 </p>
</li>
<li><p>只能保证一个共享变量的原子性</p>
<p>只对一个共享变量操作可以保证原子性，但是多个则不行,多个可以通过AtomicReference来处理或者使用锁synchronized实现。</p>
</li>
</ol>
<hr>
<h2 id="3、synchronized"><a href="#3、synchronized" class="headerlink" title="3、synchronized"></a>3、synchronized</h2><h3 id="3-2-1、synchronized关键字的底层原理（★"><a href="#3-2-1、synchronized关键字的底层原理（★" class="headerlink" title="3.2.1、synchronized关键字的底层原理（★"></a>3.2.1、synchronized关键字的底层原理（★</h3><p>在 Java 中，synchronized 关键字是用来<strong>控制线程同步</strong>的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 可以修饰类、方法、变量。 </p>
<ul>
<li>使用synchronized之后，编译之后在同步的代码块前后<strong>加上monitorenter和monitorexit字节码指令</strong>，他依赖操作系统底层互斥锁实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题,</li>
<li>执行monitorenter指令时会尝试获取对象锁，如果对象没有被锁定或者已经获得了锁，锁的<strong>计数器</strong>+1。此时其他竞争锁的线程则会进入等待队列中。执行monitorexit指令时则会把计数器-1，当计数器值为0时则锁释放，处于等待队列中的线程再继续竞争锁。</li>
<li>synchronized是<strong>排它锁</strong>，当一个线程获得锁之后，其他线程必须等待该线程释放锁后才能获得锁，而且由于Java中的线程和操作系统原生线程是一一对应的，线程被阻塞或者唤醒时时会从用户态切换到内核态这种转换非常消耗性能。</li>
</ul>
<h3 id="3-2-2、synchronized可重入的原理"><a href="#3-2-2、synchronized可重入的原理" class="headerlink" title="3.2.2、synchronized可重入的原理"></a>3.2.2、synchronized可重入的原理</h3><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。 </p>
<h3 id="3-2-3、什么是自旋"><a href="#3-2-3、什么是自旋" class="headerlink" title="3.2.3、什么是自旋"></a>3.2.3、什么是自旋</h3><p>很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为<strong>线程阻塞涉及到用户态和内核态切换</strong>的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界<strong>做忙循环</strong>，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 </p>
<h3 id="3-2-4、多线程中-synchronized-锁升级的原理是什么？"><a href="#3-2-4、多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="3.2.4、多线程中 synchronized 锁升级的原理是什么？"></a>3.2.4、多线程中 synchronized 锁升级的原理是什么？</h3><p>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<p>偏向锁：第一次使用需要CAS操作，后续再获取该锁只要线程id一样（是同一个线程）就无需再用CAS操作</p>
<p>轻量级锁：每次都需要CAS操作</p>
<p>synchronized 锁升级原理：<strong>在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象</strong>，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了<strong>偏向锁升级为轻量级锁再升级到重量级锁的方式</strong>，从而减低了锁带来的性能消耗。</p>
<p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高性能比较低。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的(也就是没有竞争)，可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
<h3 id="3-2-5、synchronized-和-volatile-的区别是什么？"><a href="#3-2-5、synchronized-和-volatile-的区别是什么？" class="headerlink" title="3.2.5、synchronized 和 volatile 的区别是什么？"></a>3.2.5、synchronized 和 volatile 的区别是什么？</h3><p>​	<code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个<strong>互补</strong>的存在，而不是对立的存在！ </p>
<ol>
<li>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</li>
<li>volatile 仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而 synchronized 则<strong>可以保证变量的修改可见性和原子性</strong>。</li>
<li>volatile 不会造成线程的<strong>阻塞</strong>；synchronized 可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。</li>
<li>volatile不能完全保证在多线程下的线程安全</li>
</ol>
<h3 id="3-2-8、synchronized和Lock有什么区别？"><a href="#3-2-8、synchronized和Lock有什么区别？" class="headerlink" title="3.2.8、synchronized和Lock有什么区别？"></a>3.2.8、synchronized和Lock有什么区别？</h3><ol>
<li>首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类；</li>
<li>synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
</ol>
<hr>
<h2 id="4、ReentrantLock"><a href="#4、ReentrantLock" class="headerlink" title="4、ReentrantLock"></a>4、ReentrantLock</h2><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。 但提供了比 <code>synchronized</code> 更细粒度的锁控制，支持公平锁、可中断锁、尝试获取锁等功能。 <strong>适用场景：</strong> 当需要更复杂的锁控制、当线程需要中断时、当锁的获取需要超时限制时， </p>
<h3 id="1、公平锁和非公平锁"><a href="#1、公平锁和非公平锁" class="headerlink" title="1、公平锁和非公平锁"></a>1、公平锁和非公平锁</h3><p><strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</p>
<p><strong>非公平锁</strong>：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。</p>
<h3 id="2、synchronized-和-ReentrantLock-的区别是什么？、"><a href="#2、synchronized-和-ReentrantLock-的区别是什么？、" class="headerlink" title="2、synchronized 和 ReentrantLock 的区别是什么？、"></a>2、synchronized 和 ReentrantLock 的区别是什么？、</h3><ul>
<li>两者都是可重入锁<ul>
<li><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</li>
</ul>
</li>
<li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API<ul>
<li>synchronized 是JM 层面通过监视器实现的，而 ReentrantLock 是基于 AQS 实现的。</li>
</ul>
</li>
<li>ReentrantLock比sychronized 增加了一些高级功能<ul>
<li>ReentrantLock 可以响应中断，解决死锁的问题，而 synchronized 不能响应中断。</li>
<li>synchronized 属于非公平锁，而 ReentrantLock 既可以是公平锁也可以是非公平锁。</li>
</ul>
</li>
</ul>
<h3 id="3、可中断锁和不可中断锁有什么区别"><a href="#3、可中断锁和不可中断锁有什么区别" class="headerlink" title="3、可中断锁和不可中断锁有什么区别?"></a>3、可中断锁和不可中断锁有什么区别?</h3><p><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</p>
<p><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</p>
<hr>
<h2 id="5、ThreadLocal"><a href="#5、ThreadLocal" class="headerlink" title="5、ThreadLocal"></a>5、ThreadLocal</h2><h3 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h3><p>ThreadLocal是线程本地变量，在多线程并发执行过程中，为保证多个线程对变量的安全访问，可以将变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立值，线程之间互不影响，相互隔离，提高了线程安全性 </p>
<h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><p>ThreadLocal底层使用ThreadLocalMap存储数据，它是一个哈希表，每个线程都有一个相关联的ThreadLocalMap。ThreadLocalMap的key是ThreadLocal实例，对应的value是需要存储的值 </p>
<ul>
<li>key：ThreadLocal </li>
<li>value：需要存储的值</li>
</ul>
<h3 id="3、内存泄露问题"><a href="#3、内存泄露问题" class="headerlink" title="3、内存泄露问题"></a>3、内存泄露问题</h3><p>使用线程池时，线程池中的线程会被重复使用。ThreadLocalMap是Thread中的一个属性，因此，ThreadLocalMap的生命周期与Thread一致。map中Entry对象的key被设置成弱引用，会被垃圾回收器回收，但是value不会被回收（ value 是强引用 ），从而造成内存泄漏。解决办法就是使用完之后调用remove()。 </p>
<hr>
<h2 id="6、线程池"><a href="#6、线程池" class="headerlink" title="6、线程池"></a>6、线程池</h2><p>作用：管理和复用线程，提高程序的性能和资源利用率，控制线程数量，避免系统过载 </p>
<ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<p>线程复用原理：线程池对 Thread 进行了封装，并不是每次执行任务都会调用 Thread.start() 来创建新线程，而是让每个线程循环检查是否还有任务等待被执行，如果有则直接去执行这个任务，也就是调用任务的 run 方法，相当于把每个任务的 run() 方法串联了起来，所以线程数量并不增加。 </p>
<h3 id="1、线程池的核心参数（线程池的执行原理）"><a href="#1、线程池的核心参数（线程池的执行原理）" class="headerlink" title="1、线程池的核心参数（线程池的执行原理）"></a>1、线程池的核心参数（线程池的执行原理）</h3><ol>
<li>corePoolSize：线程池核心线程数量</li>
<li>maximumPoolSize：线程池中最多可容纳的线程数量。 </li>
<li>keepAliveTime ：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间</li>
<li>unit ：keepAliveTime的单位</li>
<li>workQueue：线程池所使用的缓冲队列，被提交但尚未被执行的任务</li>
<li>threadFactory：线程工厂，用于创建线程</li>
<li>handler：拒绝策略，线程池任务队列超过 maxinumPoolSize 之后的拒绝策略</li>
</ol>
<p>流程</p>
<p><img src="https://cdn.xiaolincoding.com//picgo/1719389039034-0de42388-4ec6-44a6-9583-5d018e5cb4f3.png" alt="img"> </p>
<h3 id="2、线程池的拒绝策略"><a href="#2、线程池的拒绝策略" class="headerlink" title="2、线程池的拒绝策略"></a>2、<strong>线程池的拒绝策略</strong></h3><p>预置的有四种策略</p>
<ol>
<li><p>AbortPolicy(默认方式，直接抛出一个任务被线程池拒绝的异常。 </p>
</li>
<li><p>CallerRunsPolicy：由线程池的调用者所在的线程去执行被拒绝的任务 </p>
</li>
<li><p>DiscardPolicy(不做任何处理，静默拒绝提交的任务。 </p>
</li>
<li><p>DiscardOldestPolicy(丢弃最早被添加到队列的任务，然后尝试重新提交新任务)</p>
<p>如果希望快速失败并将异常传递给调用者，则选择AbortPolicy。<strong>如果希望尽可能保证任务的执行而不堆积在队列中</strong>，则选择CallerRunsPolicy。如果对任务的丢失情况不敏感，则选择 DiscardPolicy。而如果希望尽可能保留最新的任务而不是旧日的任务，则选择DiscardOldestPolicy。</p>
</li>
</ol>
<h3 id="3、线程池的大小如何设定？"><a href="#3、线程池的大小如何设定？" class="headerlink" title="3、线程池的大小如何设定？"></a>3、线程池的大小如何设定？</h3><p>N是CPU核心数，设置corePoolSize的大小为：</p>
<p>CPU密集型任务：N+1。这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N(CPU 核心数)+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<p>I&#x2F;O密集型任务：2N。这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;0 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p>
<h3 id="4、为什么不推荐使用Executors创建线程池"><a href="#4、为什么不推荐使用Executors创建线程池" class="headerlink" title="4、为什么不推荐使用Executors创建线程池"></a>4、为什么不推荐使用Executors创建线程池</h3><p>《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 <strong>ThreadPoolExecutor</strong> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p>Executors 各个方法的弊端：</p>
<p>（加粗的也是创建线程池的四种方式，分别是创建固定大小的线程池，创建一个单线程的线程池，创建可缓存的线程池，创建一个无限大小的线程池）</p>
<ul>
<li><strong>newFixedThreadPool</strong> 和 <strong>newSingleThreadExecutor:</strong></li>
</ul>
<p>​     主要问题是堆积的<strong>请求处理队列可能会耗费非常大的内存</strong>，甚至 OOM。</p>
<ul>
<li><strong>newCachedThreadPool</strong> 和 <strong>newScheduledThreadPool</strong>:<br>主要问题是<strong>线程数最大数</strong>是 Integer.MAX_VALUE，可能会<strong>创建数量非常多的线程</strong>，甚至 OOM。</li>
</ul>
<p>ThreaPoolExecutor创建线程池方式只有一种，就是走它的构造函数，参数自己指定</p>
<hr>
<h2 id="7、什么是AQS？"><a href="#7、什么是AQS？" class="headerlink" title="7、什么是AQS？"></a>7、什么是AQS？</h2><p>AQS，全称是 AbstractQueuedSynchronizer，中文意思是<strong>抽象队列同步器</strong>。AQS 就是一个抽象类，主要用来构建锁和同步器。 </p>
<p>AQS 的思想是，如果被请求的<strong>共享资源</strong>空闲，则当前线程能够成功获取资源；否则，它将进入一个<strong>等待队列</strong>，当有其他线程释放资源时，系统会挑选等待队列中的一个线程，赋予其资源。 </p>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程在AQS内部还有一个<strong>属性state</strong>，这个state就相当于是一个资源，默认是0(无锁状态)，如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li>
<li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://xcfhbx.cn/">Light</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/JUC/">http://example.com/2024/10/28/%E5%85%AB%E8%82%A1/JUC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">知行合一</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css?v=1.1.3" media="print" onload="this.media='all'"><script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/28/%E5%85%AB%E8%82%A1/%E6%A1%86%E6%9E%B6/" title="框架"><img class="cover" src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">框架</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/23/%E7%99%BD%E9%AA%A1%E5%A4%B4%E6%9D%A1/" title="白骡头条"><img class="cover" src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">白骡头条</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Light</div><div class="author-info__description">警惕“知识诅咒”</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Big-Light/Big-Light.github.io.git"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎光临我的博客！目前还在美化中，后续会慢慢丰富一下内容的。记录一下自己的学习过程和一些生活日记</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-text">1、线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1、线程和进程的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2、并行与并发有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F-%E5%9B%9B%E7%A7%8D%EF%BC%89"><span class="toc-text">3、创建线程的方式有哪些？(四种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4、runnable 和 callable 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">5、run()和 start()有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-text">6、线程包括哪些状态？状态之间是如何变化的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81notify%EF%BC%88%EF%BC%89%E5%92%8CnotifyAll%EF%BC%88%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">7、notify（）和notifyAll（）的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81Java%E4%B8%ADsleep%E5%92%8Cwait%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-text">8、Java中sleep和wait方法有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-text">8、如何停止一个正在运行的线程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">9、线程&#x2F;进程之间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E8%AF%B4%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%89%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8-Java-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">10、导致并发程序出现问题的根本原因是说什么？（Java程序中怎么保证多线程的执行安全）并发编程三要素是什么？在 Java 程序中怎么保证多线程的运行安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">11、死锁产生的条件是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Thread%E7%9A%84run%E6%96%B9%E6%B3%95%E5%90%97%EF%BC%9F"><span class="toc-text">12、可以直接调用Thread的run方法吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5"><span class="toc-text">13、同步&#x2F;异步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81voliatle"><span class="toc-text">2、voliatle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">3、乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-6%E3%80%81CAS%E5%AD%98%E5%9C%A8%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%88%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-text">3.2.6、CAS存在的缺点（问题）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81synchronized"><span class="toc-text">3、synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E2%98%85"><span class="toc-text">3.2.1、synchronized关键字的底层原理（★</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E3%80%81synchronized%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">3.2.2、synchronized可重入的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E6%97%8B"><span class="toc-text">3.2.3、什么是自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.2.4、多线程中 synchronized 锁升级的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5%E3%80%81synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">3.2.5、synchronized 和 volatile 的区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-8%E3%80%81synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.2.8、synchronized和Lock有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81ReentrantLock"><span class="toc-text">4、ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">1、公平锁和非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81synchronized-%E5%92%8C-ReentrantLock-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E3%80%81"><span class="toc-text">2、synchronized 和 ReentrantLock 的区别是什么？、</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">3、可中断锁和不可中断锁有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81ThreadLocal"><span class="toc-text">5、ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1、是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8E%9F%E7%90%86"><span class="toc-text">2、原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-text">3、内存泄露问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">6、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-text">1、线程池的核心参数（线程池的执行原理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-text">2、线程池的拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E5%AE%9A%EF%BC%9F"><span class="toc-text">3、线程池的大小如何设定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">4、为什么不推荐使用Executors创建线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F"><span class="toc-text">7、什么是AQS？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/18/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E8%AE%B0%E5%BD%95/" title="黑马点评记录"><img src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="黑马点评记录"/></a><div class="content"><a class="title" href="/2024/12/18/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E8%AE%B0%E5%BD%95/" title="黑马点评记录">黑马点评记录</a><time datetime="2024-12-18T14:28:12.000Z" title="发表于 2024-12-18 22:28:12">2024-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/%E9%9D%A2%E7%BB%8F/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E7%95%AA%E8%8C%84%E5%B0%8F%E8%AF%B4%E9%9D%A2%E7%BB%8F/" title="字节跳动-番茄小说面经"><img src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字节跳动-番茄小说面经"/></a><div class="content"><a class="title" href="/2024/12/14/%E9%9D%A2%E7%BB%8F/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8-%E7%95%AA%E8%8C%84%E5%B0%8F%E8%AF%B4%E9%9D%A2%E7%BB%8F/" title="字节跳动-番茄小说面经">字节跳动-番茄小说面经</a><time datetime="2024-12-14T03:17:09.000Z" title="发表于 2024-12-14 11:17:09">2024-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/%E9%9D%A2%E7%BB%8F/%E4%B8%AD%E7%A7%91%E6%98%9F%E5%9B%BE%E9%9D%A2%E7%BB%8F/" title="中科星图面经"><img src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="中科星图面经"/></a><div class="content"><a class="title" href="/2024/12/14/%E9%9D%A2%E7%BB%8F/%E4%B8%AD%E7%A7%91%E6%98%9F%E5%9B%BE%E9%9D%A2%E7%BB%8F/" title="中科星图面经">中科星图面经</a><time datetime="2024-12-14T03:16:45.000Z" title="发表于 2024-12-14 11:16:45">2024-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/13/hot100%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%9D%E8%B7%AF/" title="hot100一句话思路"><img src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hot100一句话思路"/></a><div class="content"><a class="title" href="/2024/12/13/hot100%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%9D%E8%B7%AF/" title="hot100一句话思路">hot100一句话思路</a><time datetime="2024-12-13T13:33:20.000Z" title="发表于 2024-12-13 21:33:20">2024-12-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/28/%E5%85%AB%E8%82%A1/%E5%85%B6%E5%AE%83/" title="其它"><img src="https://pic.imgdb.cn/item/66ffa4b7d29ded1a8cbc9e59.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="其它"/></a><div class="content"><a class="title" href="/2024/11/28/%E5%85%AB%E8%82%A1/%E5%85%B6%E5%AE%83/" title="其它">其它</a><time datetime="2024-11-28T12:57:13.000Z" title="发表于 2024-11-28 20:57:13">2024-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 By Light</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js?v=5.0.33"></script><script src="/pluginsSrc/instant.page/instantpage.js?v=5.2.0" type="module"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js?v=0.1.16"></script><div class="js-pjax"></div><script src="/js/sakura.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/pluginsSrc/butterfly-extsrc/dist/canvas-nest.min.js?v=1.1.3"></script><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js?v=1.1.3"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="/pluginsSrc/butterfly-extsrc/dist/click-heart.min.js?v=1.1.3" async="async" mobile="true"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>